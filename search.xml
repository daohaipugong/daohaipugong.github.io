<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STL &amp; 各种函数、容器</title>
    <url>/2024/11/25/STL%20&amp;%20%E5%90%84%E7%A7%8D%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>Fragmented knowledge points+STL</p>
<span id="more"></span>

<h2 id="STL各种容器常数"><a href="#STL各种容器常数" class="headerlink" title="STL各种容器常数"></a>STL各种容器常数</h2><p>均为大约值</p>
<ul>
<li><code>vector</code>：1</li>
<li><code>queue</code>：1</li>
<li><code>map</code>：13</li>
<li><code>unoredred_map</code>：8</li>
</ul>
<h2 id="bitset"><a href="#bitset" class="headerlink" title="bitset()"></a>bitset()</h2><ul>
<li>相当于一个二进制的数组，并且可以直接用 <code>01</code> 串赋值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;4&gt;a1;<span class="comment">//长度为4，默认以0填充</span></span><br><span class="line">bitset&lt;8&gt;<span class="built_in">a2</span>(<span class="number">12</span>);<span class="comment">//长度为8，将12以二进制保存，前面用0补充</span></span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;100101&quot;</span>;</span><br><span class="line">bitset&lt;10&gt;<span class="built_in">a3</span>(s);<span class="comment">//长度为10，前面用０补充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c++11下，char可以赋值给bitset</span></span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;10101&quot;</span>;</span><br><span class="line">bitset&lt;13&gt;<span class="built_in">a4</span>(s2);<span class="comment">//长度为13，前面用０补充</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;a1&lt;&lt;endl;<span class="comment">//0000</span></span><br><span class="line">cout&lt;&lt;a2&lt;&lt;endl;<span class="comment">//00001100</span></span><br><span class="line">cout&lt;&lt;a3&lt;&lt;endl;<span class="comment">//0000100101</span></span><br><span class="line">cout&lt;&lt;a4&lt;&lt;endl;<span class="comment">//0000000010101</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果超出了 <code>bitset</code> 定义的范围：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;2&gt;<span class="built_in">bitset1</span>(<span class="number">12</span>);<span class="comment">//12的二进制为1100（长度为４），但bitset1的size=2，只取后面部分，即00</span></span><br><span class="line"></span><br><span class="line">string s=<span class="string">&quot;100101&quot;</span>;</span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bitset2</span><span class="params">(s)</span></span>;<span class="comment">//s的size=6，而bitset的size=4，只取前面部分，即1001</span></span><br></pre></td></tr></table></figure>

<ul>
<li>位运算操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">foo</span> <span class="params">(string(<span class="string">&quot;1001&quot;</span>))</span></span>;<span class="comment">//这种赋值方式就可以直接用，没有限制</span></span><br><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bar</span> <span class="params">(string(<span class="string">&quot;0011&quot;</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; (foo^=bar) &lt;&lt; endl;       <span class="comment">// 1010 (foo对bar按位异或后赋值给foo)</span></span><br><span class="line">cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;       <span class="comment">// 0010 (按位与后赋值给foo)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>单一元素访问和修改</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;4&gt;<span class="built_in">a1</span>(<span class="string">&quot;1011&quot;</span>);<span class="comment">//这个赋值方法只能在c++11里用</span></span><br><span class="line">bitset&lt;4&gt;<span class="built_in">a1</span>(<span class="built_in">string</span>(<span class="string">&quot;1011&quot;</span>));</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;a1[<span class="number">0</span>]&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">cout&lt;&lt;a1[<span class="number">1</span>]&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line">cout&lt;&lt;a1[<span class="number">2</span>]&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">cout&lt;&lt;a1[<span class="number">3</span>]&lt;&lt;endl;<span class="comment">//1</span></span><br><span class="line"><span class="comment">//注意！这两种赋值方式都是反序赋值的</span></span><br><span class="line"><span class="comment">//可以直接输出a1来输出正序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bitset支持单点修改</span></span><br><span class="line">a1[<span class="number">0</span>]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>各种函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;8&gt;<span class="built_in">foo</span>(<span class="built_in">string</span>(<span class="string">&quot;10011011&quot;</span>));</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.<span class="built_in">count</span>()&lt;&lt;endl;<span class="comment">//5　　（count函数用来求bitset中1的位数，foo中共有５个１</span></span><br><span class="line">cout&lt;&lt;foo.<span class="built_in">size</span>()&lt;&lt;endl;<span class="comment">//8　　（size函数用来求bitset的大小，一共有８位</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.<span class="built_in">test</span>(<span class="number">0</span>)&lt;&lt; endl;<span class="comment">//true　　（test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回true</span></span><br><span class="line">cout&lt;&lt;foo.<span class="built_in">test</span>(<span class="number">2</span>)&lt;&lt;endl;<span class="comment">//false　　（同理，foo[2]为０，返回false</span></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.<span class="built_in">any</span>()&lt;&lt;endl;<span class="comment">//true　　（any函数检查bitset中是否有１</span></span><br><span class="line">cout&lt;&lt;foo.<span class="built_in">none</span>()&lt;&lt;endl;<span class="comment">//false　　（none函数检查bitset中是否没有１</span></span><br><span class="line">cout&lt;&lt;foo.<span class="built_in">all</span>()&lt;&lt;endl;<span class="comment">//false　　（all函数检查bitset中是全部为１</span></span><br></pre></td></tr></table></figure>

<h2 id="compare"><a href="#compare" class="headerlink" title=".compare()"></a>.compare()</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从3开始，包含4个字符</span></span><br><span class="line"><span class="comment">1: &gt;</span></span><br><span class="line"><span class="comment">0: ==</span></span><br><span class="line"><span class="comment">-1: &lt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">a.<span class="built_in">compare</span>(<span class="number">3</span>,<span class="number">4</span>,b,<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>$2$ 进制第 $k$ 位上 $1$ 的个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 ~ n 中第 k 位上 1 的个数, 0 &lt;= n, 0 &lt;= k &lt;= 62</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">get</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n) / (<span class="number">1LL</span> &lt;&lt; k + <span class="number">1</span>) * (<span class="number">1LL</span> &lt;&lt; k) + <span class="built_in">max</span>((n) % (<span class="number">1LL</span> &lt;&lt; k + <span class="number">1</span>) + <span class="number">1</span> - (<span class="number">1LL</span> &lt;&lt; k), <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="iota"><a href="#iota" class="headerlink" title="iota()"></a>iota()</h2><p><code>iota</code>是一个算法函数，定义在头文件<code>&lt;numeric&gt;</code>中，用于生成一个连续递增的序列。具体来说，<code>iota</code>函数接受三个参数：两个迭代器（<code>first</code>和<code>last</code>），它们定义了要填充的序列的范围（注意，<code>last</code>是范围之外的第一个位置，即不包括<code>last</code>），以及一个初始值（<code>value</code>）。<code>iota</code>函数会从<code>first</code>开始，逐个将递增的值赋给范围内的元素，直到<code>last</code>（不包括<code>last</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="built_in">iota</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h2 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h2><p><code>C++</code> 内置对数函数只有以 $e$ 为底和以 $10$ 为底的，如果想要以 $m$ 为底的对数可以借助如下公式：</p>
<p>$ loga(n)&#x2F;loga(m) &#x3D; logm(n) $ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> res = <span class="built_in">log</span>(n)/<span class="built_in">log</span>(m);    <span class="comment">//res = logm(n)</span></span><br></pre></td></tr></table></figure>

<h2 id="lowbit"><a href="#lowbit" class="headerlink" title="lowbit()"></a>lowbit()</h2><p>找一个数 $2$ 进制下的最低位的 $1$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &amp; -x ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br></pre></td></tr></table></figure>

<h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound&#x2F;upper_bound()"></a>lower_bound&#x2F;upper_bound()</h2><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>lower_bound</code> 返回第一个大于等于x的元素的位置的迭代器（或指针）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="built_in">lower_bound</span>(a<span class="number">+1</span>,a+n<span class="number">+1</span>,x)-a;</span><br></pre></td></tr></table></figure>

<p><code>upper_bound</code> 返回第一个    大于   $x$ 的元素的位置的迭代器（或指针）。</p>
<p>在有序 <code>vector</code> 中查找小于等于 $x$ 的最大整数（假设一定存在)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> y=*--<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),x);</span><br></pre></td></tr></table></figure>

<h4 id="比较函数"><a href="#比较函数" class="headerlink" title="比较函数"></a>比较函数</h4><p>若数组降序排列，可写上比较函数 <code>greater&lt;type&gt;()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">lower_bound</span>(begin, end, a, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) <span class="comment">// 返回数组[begin, end)之间第一个小于或等于a的地址，找不到返回end</span></span><br><span class="line"><span class="built_in">upper_bound</span>(begin, end, a, <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()) <span class="comment">// 返回数组[begin, end)之间第一个小于a的地址，找不到返回end</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义比较函数</strong></p>
<p><code>lower_bound/upper_bound</code> <strong>默认操作</strong>都是 <strong>&lt;</strong> 。</p>
<p><code>lower_bound</code> 返回第一个使 <code>cmp(element,value)</code> 为 $false$ 的元素位置（<code>element</code> 为序列的元素，<code>value</code> 为比较参数）。<code>upper_bound</code> 少用。</p>
<p><strong>查找第一个小于x的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v从小到大排序</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> e,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e&gt;=val;             <span class="comment">// &gt;  查找第一个&lt;=x的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t=<span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),x,cmp)-v.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">cout&lt;&lt;t;</span><br></pre></td></tr></table></figure>

<p><strong>查找第一个不能被val整除的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> e,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> e%val==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>利用 <code>map</code> 可以简单实现 <code>hash</code>，离散化等操作。</p>
<h3 id="map-1"><a href="#map-1" class="headerlink" title="map"></a>map</h3><p><code>map</code>：基于红黑树，元素有序存储；增删查改时间复杂度为 $O(logN)$。</p>
<p>利用 $map$ 排序特性可以查找 $key&#x3D;x$ 的前一个元素和后一个元素，利用迭代器返回，不存在返回 <code>mp.end()</code>；</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">mp[<span class="number">5</span>] = <span class="number">50</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">auto</span> l = mp.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> r = l;</span><br><span class="line">l--;r++;</span><br><span class="line">cout &lt;&lt; l-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; r-&gt;first &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p><code>unordered_map：</code>基于散列表，元素无序存储；大多数情况下其复杂度接近于 $O(1)$。</p>
<h2 id="memset"><a href="#memset" class="headerlink" title="memset()"></a>memset()</h2><p>可以初始化为 $-1，0，0x3f$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//因为一个 int 是四个字节，所以 memset 会把每个字节初始化为你给的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">1</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>) </span><br><span class="line"><span class="number">00000001</span> <span class="number">00000001</span> <span class="number">00000001</span> <span class="number">00000001</span>   <span class="comment">//每个字节初始化为1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">2</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>)*<span class="number">10</span>) </span><br><span class="line"><span class="number">00000010</span> <span class="number">00000010</span> <span class="number">00000010</span> <span class="number">00000010</span>  每个字节初始化为<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h2><p>四舍五入函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="type">int</span> t=<span class="built_in">round</span>(x);<span class="comment">// 将浮点数四舍五入为整数</span></span><br><span class="line"><span class="type">double</span> t = <span class="built_in">round</span>(x*<span class="number">100</span>)/<span class="number">100.0</span>  <span class="comment">//保留浮点数的前两位小数</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">my_round</span>(<span class="type">double</span> x) &#123;        <span class="comment">//手写round()函数   ##小数点13位以后会出现精度问题</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">return</span> (<span class="type">int</span>)(x - <span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(x + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p>is_sorted()</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断 [first, last) 区域内的数据是否符合 std::less&lt;T&gt; 排序规则，即是否为升序序列</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sorted</span> <span class="params">(ForwardIterator first, ForwardIterator last)</span></span>;</span><br><span class="line"><span class="comment">//判断 a 内的数据是否符合 cmp 排序规则  </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sorted</span> <span class="params">(a.begin(), a.end(), cmp)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="strstol"><a href="#strstol" class="headerlink" title="strstol()"></a>strstol()</h2><p>long int strtol(const char *str, char **endptr, int base) ；</p>
<p><code>strtol()</code> 会将 $str$ 指向的字符串，根据参数 $base$，按权转化为 $long int$ ，然后返回这个值。</p>
<p><code>base</code> 必须介于 $2$ 和 $36$（包含）之间，或者是特殊值 $0$；</p>
<p><code>str</code>中不符合 $base$ 的部分存储于 <code>*endptr</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="type">char</span> *endptr;</span><br><span class="line">cin&gt;&gt;str;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">strtol</span>(str,&amp;endptr,<span class="number">2</span>);</span><br><span class="line">cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;endptr;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①如果base为0，且字符串不是以0x(或者0X)开头，则按十进制进行转化。</span><br><span class="line">②如果base为0或者16，并且字符串以0x（或者0X）开头，那么，x（或者X）被忽略，字符串按16进制转化。</span><br><span class="line">③如果base不等于0和16，并且字符串以0x(或者0X)开头，那么x被视为非法字符。</span><br><span class="line">④对于nptr指向的字符串，其开头和结尾处的空格被忽视，字符串中间的空格被视为非法字符。</span><br></pre></td></tr></table></figure>

<h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p><code>swap</code> 交换数组是 $O(n)$ ，（开 <code>c++11</code> 后）交换 $STL$ 是 $O(1)$ 。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><a href="https://blog.csdn.net/weixin_44205193/article/details/121522516#:~:text=%E6%9C%AC%E6%96%87%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BA%86C%2B%2B">vector中间插入元素</a></p>
<h2 id="日历"><a href="#日历" class="headerlink" title="日历"></a>日历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dm[] = &#123; <span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">date</span> &#123;</span><br><span class="line">	<span class="type">int</span> y, m, d;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">pf</span><span class="params">(<span class="type">int</span> yy, <span class="type">int</span> mm)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mm != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> ((yy % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; yy % <span class="number">100</span> != <span class="number">0</span>) || yy % <span class="number">400</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加x天</span></span><br><span class="line">	<span class="function">date <span class="title">addd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		date a = *<span class="keyword">this</span>;</span><br><span class="line">		a.d += x;</span><br><span class="line">		<span class="keyword">while</span> (a.d &gt; dm[a.m] + <span class="built_in">pf</span>(a.y, a.m)) &#123;</span><br><span class="line">			a.d -= dm[a.m] + <span class="built_in">pf</span>(a.y, a.m);</span><br><span class="line">			<span class="keyword">if</span> (++a.m &gt; <span class="number">12</span>) &#123; a.m = <span class="number">1</span>; a.y++; &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 加x个月</span></span><br><span class="line">	<span class="function">date <span class="title">addm</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		date a = *<span class="keyword">this</span>;</span><br><span class="line">		a.m += x;</span><br><span class="line">		<span class="keyword">while</span> (a.m &gt; <span class="number">12</span>) &#123; a.y++; a.m -= <span class="number">12</span>; &#125;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 判断日期是否合法</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (d &gt; dm[m] + <span class="built_in">pf</span>(y, m)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> date&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (y != b.y) <span class="keyword">return</span> y &gt; b.y;</span><br><span class="line">		<span class="keyword">if</span> (m != b.m) <span class="keyword">return</span> m &gt; b.m;</span><br><span class="line">		<span class="keyword">return</span> d &gt; b.d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> date&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (y != b.y) <span class="keyword">return</span> y &lt; b.y;</span><br><span class="line">		<span class="keyword">if</span> (m != b.m) <span class="keyword">return</span> m &lt; b.m;</span><br><span class="line">		<span class="keyword">return</span> d &lt; b.d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> date&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (y == b.y &amp;&amp; m == b.m &amp;&amp; d == b.d) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="小波树"><a href="#小波树" class="headerlink" title="小波树"></a>小波树</h2><p>时间复杂度都是 $logn$ 。</p>
<p>所有的下标都是从 $0$ 开始。</p>
<p>区间第 $k$ 小（ $k$ 从 $0$ 开始，$k&#x3D;1$ 代表第$ 2$ 小）。</p>
<p>区间某个数出现的频率（如果 $val$ 不在数据集中会返回错误的值）。</p>
<p>区间小于等于某个数的个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitRank</span> &#123;</span><br><span class="line">    <span class="comment">// block 管理一行一行的bit</span></span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; block;</span><br><span class="line">    std::vector&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="built_in">BitRank</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 位向量长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        block.<span class="built_in">resize</span>(((num + <span class="number">1</span>) &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        count.<span class="built_in">resize</span>(block.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置i位bit</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">        block[i &gt;&gt; <span class="number">6</span>] |= (val &lt;&lt; (i &amp; <span class="number">63</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt; block.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count[i] = count[i - <span class="number">1</span>] + __builtin_popcountll(block[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [0, i) 1的个数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">rank1</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count[i &gt;&gt; <span class="number">6</span>] +</span><br><span class="line">            __builtin_popcountll(block[i &gt;&gt; <span class="number">6</span>] &amp; ((<span class="number">1ULL</span> &lt;&lt; (i &amp; <span class="number">63</span>)) - <span class="number">1ULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [i, j) 1的个数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">rank1</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> j)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rank1</span>(j) - <span class="built_in">rank1</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [0, i) 0的个数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">rank0</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> i - <span class="built_in">rank1</span>(i); &#125;</span><br><span class="line">    <span class="comment">// [i, j) 0的个数</span></span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">rank0</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> j)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rank0</span>(j) - <span class="built_in">rank0</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaveletMatrix</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> height;</span><br><span class="line">    std::vector&lt;BitRank&gt; B;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WaveletMatrix</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">WaveletMatrix</span>(std::vector&lt;<span class="type">int</span>&gt; vec)</span><br><span class="line">        : <span class="built_in">WaveletMatrix</span>(vec, *std::<span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// sigma: 字母表大小(字符串的话)，数字序列的话是数的种类</span></span><br><span class="line">    <span class="built_in">WaveletMatrix</span>(std::vector&lt;<span class="type">int</span>&gt; vec, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> sigma) &#123;</span><br><span class="line">        <span class="built_in">init</span>(vec, sigma);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> sigma)</span> </span>&#123;</span><br><span class="line">        height = (sigma == <span class="number">1</span>) ? <span class="number">1</span> : (<span class="number">64</span> - __builtin_clzll(sigma - <span class="number">1</span>));</span><br><span class="line">        B.<span class="built_in">resize</span>(height), pos.<span class="built_in">resize</span>(height);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; height; ++i) &#123;</span><br><span class="line">            B[i].<span class="built_in">resize</span>(vec.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                B[i].<span class="built_in">set</span>(j, <span class="built_in">get</span>(vec[j], height - i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            B[i].<span class="built_in">build</span>();</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">stable_partition</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> c) &#123;</span><br><span class="line">                <span class="keyword">return</span> !<span class="built_in">get</span>(c, height - i - <span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            pos[i] = it - vec.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">int</span> val, <span class="type">const</span> <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> val &gt;&gt; i &amp; <span class="number">1</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [l, r) 中val出现的频率</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">const</span> <span class="type">int</span> val, <span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rank</span>(val, r) - <span class="built_in">rank</span>(val, l);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// [0, i) 中val出现的频率</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>; j &lt; height; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(val, height - j - <span class="number">1</span>)) &#123;</span><br><span class="line">                p = pos[j] + B[j].<span class="built_in">rank1</span>(p);</span><br><span class="line">                i = pos[j] + B[j].<span class="built_in">rank1</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = B[j].<span class="built_in">rank0</span>(p);</span><br><span class="line">                i = B[j].<span class="built_in">rank0</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i - p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l, r) 中k小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quantile</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; height; ++i) &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> j = B[i].<span class="built_in">rank0</span>(l, r);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">                l = B[i].<span class="built_in">rank0</span>(l);</span><br><span class="line">                r = B[i].<span class="built_in">rank0</span>(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = pos[i] + B[i].<span class="built_in">rank1</span>(l);</span><br><span class="line">                r = pos[i] + B[i].<span class="built_in">rank1</span>(r);</span><br><span class="line">                k -= j;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; (height - i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangefreq</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, <span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b, <span class="type">const</span> <span class="type">int</span> l,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j || r &lt;= a || b &lt;= l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">            <span class="keyword">return</span> j - i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> left =</span><br><span class="line">                <span class="built_in">rangefreq</span>(B[x].<span class="built_in">rank0</span>(i), B[x].<span class="built_in">rank0</span>(j), a, b, l, mid, x + <span class="number">1</span>);</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> right = <span class="built_in">rangefreq</span>(pos[x] + B[x].<span class="built_in">rank1</span>(i),</span><br><span class="line">                                        pos[x] + B[x].<span class="built_in">rank1</span>(j), a, b, mid, r, x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l,r) 在[a, b) 值域的数字个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangefreq</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangefreq</span>(l, r, a, b, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; height, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangemin</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i, <span class="type">const</span> <span class="type">int</span> j, <span class="type">const</span> <span class="type">int</span> a, <span class="type">const</span> <span class="type">int</span> b, <span class="type">const</span> <span class="type">int</span> l,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> x, <span class="type">const</span> <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j || r &lt;= a || b &lt;= l) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> res =</span><br><span class="line">            <span class="built_in">rangemin</span>(B[x].<span class="built_in">rank0</span>(i), B[x].<span class="built_in">rank0</span>(j), a, b, l, mid, x + <span class="number">1</span>, val);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rangemin</span>(pos[x] + B[x].<span class="built_in">rank1</span>(i), pos[x] + B[x].<span class="built_in">rank1</span>(j), a, b, mid,</span><br><span class="line">                            r, x + <span class="number">1</span>, val + (<span class="number">1</span> &lt;&lt; (height - x - <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l,r) 在[a,b) 值域内存在的最小值是什么，不存在返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangemin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangemin</span>(l, r, a, b, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; height, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="简化版（不保证对）"><a href="#简化版（不保证对）" class="headerlink" title="简化版（不保证对）"></a>简化版（不保证对）</h3><p>内存，时间都增大为160%</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BitRank</span> &#123;</span><br><span class="line">    <span class="comment">// block 管理一行一行的bit</span></span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; block;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; count;</span><br><span class="line">    <span class="built_in">BitRank</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 位向量长度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        block.<span class="built_in">resize</span>(((num + <span class="number">1</span>) &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        count.<span class="built_in">resize</span>(block.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置i位bit</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> i, <span class="type">long</span> <span class="type">long</span> val)</span> </span>&#123;</span><br><span class="line">        block[i &gt;&gt; <span class="number">6</span>] |= (val &lt;&lt; (i &amp; <span class="number">63</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; block.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            count[i] = count[i - <span class="number">1</span>] + __builtin_popcountll(block[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [0, i) 1的个数</span></span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">rank1</span><span class="params">(<span class="type">int</span> i)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count[i &gt;&gt; <span class="number">6</span>] +</span><br><span class="line">            __builtin_popcountll(block[i &gt;&gt; <span class="number">6</span>] &amp; ((<span class="number">1ULL</span> &lt;&lt; (i &amp; <span class="number">63</span>)) - <span class="number">1ULL</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [i, j) 1的个数</span></span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">rank1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rank1</span>(j) - <span class="built_in">rank1</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [0, i) 0的个数</span></span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">rank0</span><span class="params">(<span class="type">int</span> i)</span>  </span>&#123; <span class="keyword">return</span> i - <span class="built_in">rank1</span>(i); &#125;</span><br><span class="line">    <span class="comment">// [i, j) 0的个数</span></span><br><span class="line">     <span class="function"><span class="type">int</span> <span class="title">rank0</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rank0</span>(j) - <span class="built_in">rank0</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WM</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    vector&lt;BitRank&gt; B;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WM</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">WM</span>(vector&lt;<span class="type">int</span>&gt; vec)</span><br><span class="line">        : <span class="built_in">WM</span>(vec, *<span class="built_in">max_element</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>()) + <span class="number">1</span>) &#123;&#125;</span><br><span class="line">    <span class="comment">// sigma: 字母表大小(字符串的话)，数字序列的话是数的种类</span></span><br><span class="line">    <span class="built_in">WM</span>(vector&lt;<span class="type">int</span>&gt; vec, <span class="type">int</span> sigma) &#123;</span><br><span class="line">        <span class="built_in">init</span>(vec, sigma);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; vec, <span class="type">int</span> sigma)</span> </span>&#123;</span><br><span class="line">        height = (sigma == <span class="number">1</span>) ? <span class="number">1</span> : (<span class="number">64</span> - __builtin_clzll(sigma - <span class="number">1</span>));</span><br><span class="line">        B.<span class="built_in">resize</span>(height), pos.<span class="built_in">resize</span>(height);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; height; ++i) &#123;</span><br><span class="line">            B[i].<span class="built_in">resize</span>(vec.<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; vec.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                B[i].<span class="built_in">set</span>(j, <span class="built_in">get</span>(vec[j], height - i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            B[i].<span class="built_in">build</span>();</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">stable_partition</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> c) &#123;</span><br><span class="line">                <span class="keyword">return</span> !<span class="built_in">get</span>(c, height - i - <span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            pos[i] = it - vec.<span class="built_in">begin</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> val &gt;&gt; i &amp; <span class="number">1</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [l, r) 中val出现的频率</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rank</span>(val, r) - <span class="built_in">rank</span>(val, l);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// [0, i) 中val出现的频率</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> j = <span class="number">0</span>; j &lt; height; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">get</span>(val, height - j - <span class="number">1</span>)) &#123;</span><br><span class="line">                p = pos[j] + B[j].<span class="built_in">rank1</span>(p);</span><br><span class="line">                i = pos[j] + B[j].<span class="built_in">rank1</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = B[j].<span class="built_in">rank0</span>(p);</span><br><span class="line">                i = B[j].<span class="built_in">rank0</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i - p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l, r) 中k小</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quantile</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; height; ++i) &#123;</span><br><span class="line">             <span class="type">int</span> j = B[i].<span class="built_in">rank0</span>(l, r);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; k) &#123;</span><br><span class="line">                l = B[i].<span class="built_in">rank0</span>(l);</span><br><span class="line">                r = B[i].<span class="built_in">rank0</span>(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = pos[i] + B[i].<span class="built_in">rank1</span>(l);</span><br><span class="line">                r = pos[i] + B[i].<span class="built_in">rank1</span>(r);</span><br><span class="line">                k -= j;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; (height - i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangefreq</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j || r &lt;= a || b &lt;= l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">            <span class="keyword">return</span> j - i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="type">int</span> left =</span><br><span class="line">                <span class="built_in">rangefreq</span>(B[x].<span class="built_in">rank0</span>(i), B[x].<span class="built_in">rank0</span>(j), a, b, l, mid, x + <span class="number">1</span>);</span><br><span class="line">             <span class="type">int</span> right = <span class="built_in">rangefreq</span>(pos[x] + B[x].<span class="built_in">rank1</span>(i),</span><br><span class="line">                                        pos[x] + B[x].<span class="built_in">rank1</span>(j), a, b, mid, r, x + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> left + right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l,r) 在[a, b) 值域的数字个数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangefreq</span><span class="params">( <span class="type">int</span> l,  <span class="type">int</span> r,  <span class="type">int</span> a,  <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangefreq</span>(l, r, a, b, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; height, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangemin</span><span class="params">( <span class="type">int</span> i,  <span class="type">int</span> j,  <span class="type">int</span> a,  <span class="type">int</span> b,  <span class="type">int</span> l, <span class="type">int</span> r,  <span class="type">int</span> x,  <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j || r &lt;= a || b &lt;= l) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - l == <span class="number">1</span>) <span class="keyword">return</span> val;</span><br><span class="line">         <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         <span class="type">int</span> res =</span><br><span class="line">            <span class="built_in">rangemin</span>(B[x].<span class="built_in">rank0</span>(i), B[x].<span class="built_in">rank0</span>(j), a, b, l, mid, x + <span class="number">1</span>, val);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">rangemin</span>(pos[x] + B[x].<span class="built_in">rank1</span>(i), pos[x] + B[x].<span class="built_in">rank1</span>(j), a, b, mid,</span><br><span class="line">                            r, x + <span class="number">1</span>, val + (<span class="number">1</span> &lt;&lt; (height - x - <span class="number">1</span>)));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [l,r) 在[a,b) 值域内存在的最小值是什么，不存在返回-1</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rangemin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangemin</span>(l, r, a, b, <span class="number">0</span>, <span class="number">1</span> &lt;&lt; height, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>对于 $n≥5$，它们的 $(n−2)$ 进制表示都是 $12$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check1</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="keyword">return</span> c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> c-<span class="string">&#x27;A&#x27;</span><span class="number">+10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">check2</span><span class="params">(<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c&gt;=<span class="number">0</span>&amp;&amp;c&lt;=<span class="number">9</span>) <span class="keyword">return</span> c+<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> c<span class="number">-10</span>+<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将base进制的str转化成10进制 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trans1</span><span class="params">(<span class="type">int</span> base,string str)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,p=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=str.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		ans+=<span class="built_in">check1</span>(str[i])*p;</span><br><span class="line">		p=p*base; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将10进制的x转化为base进制</span></span><br><span class="line"><span class="function">string <span class="title">trans2</span><span class="params">(<span class="type">int</span> base,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	string str;</span><br><span class="line">	<span class="keyword">while</span>(x)&#123;</span><br><span class="line">		str.<span class="built_in">push_back</span>(<span class="built_in">check2</span>(x%base));</span><br><span class="line">		x=x/base;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(str.<span class="built_in">begin</span>(),str.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将base1进制的s转化为base2进制</span></span><br><span class="line"><span class="function">string <span class="title">trans</span><span class="params">(<span class="type">int</span> base1,string s,<span class="type">int</span> base2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">trans2</span>(base2,<span class="built_in">trans1</span>(base1,s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用技巧</title>
    <url>/2024/11/25/Typora%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>使用技巧</p>
<span id="more"></span>

<h2 id="改变字体大小、颜色"><a href="#改变字体大小、颜色" class="headerlink" title="改变字体大小、颜色"></a>改变字体大小、颜色</h2><p><span style='color:文字颜色;background:背景颜色;font-size:文字大小;font-family:字体;'>文字</span></p>
<p><span style='color:文字颜色;background:背景颜色;font-size:文字大小;font-family:宋体;'>文字</span></p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>ctrl+k：添加超链接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      _______</span><br><span class="line">     <span class="comment">//  ||\ \</span></span><br><span class="line"><span class="comment"> ___//___||_\ \___</span></span><br><span class="line"> )  _          _    \</span><br><span class="line"> |_/ \________/ \___|</span><br><span class="line">___\_/________\_/______</span><br></pre></td></tr></table></figure>

<p><a href="https://www.latexlive.com/##">在线LaTeX公式编辑器-编辑器 (latexlive.com)</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vector不能用memset()</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">a</span>(n<span class="number">+3</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+3</span>));</span><br><span class="line">vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">a</span>(n<span class="number">+3</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m<span class="number">+3</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(h<span class="number">+3</span>)));</span><br><span class="line"><span class="keyword">auto</span> check=[&amp;](<span class="type">int</span> x)&#123;</span><br><span class="line">    <span class="type">int</span> pre=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j]&lt;=x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&lt;pre) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                pre=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;array&lt;<span class="type">int</span>,3&gt;&gt; que;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[a,b,c]:que) cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>使用文档</tag>
      </tags>
  </entry>
  <entry>
    <title>dp</title>
    <url>/2024/11/25/dp/</url>
    <content><![CDATA[<p>动态规划</p>
<span id="more"></span>

<p>初始化</p>
<h2 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h2><h3 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h3><p><a href="https://www.luogu.com.cn/problem/P1020">导弹拦截 - 洛谷 </a></p>
<p>STL 二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严格上升：  &gt;		lower_bound()</span></span><br><span class="line"><span class="comment">// 不严格上升：&gt;=		upper_bound()</span></span><br><span class="line"><span class="comment">// 严格下降：  &lt;     lower_bound()	greater&lt;int&gt;()</span></span><br><span class="line"><span class="comment">// 不严格下降：&lt;=		upper_bound()	greater&lt;int&gt;()</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()||a[i]&gt;stk.<span class="built_in">back</span>()) stk.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">    <span class="keyword">else</span> *<span class="built_in">lower_bound</span>(stk.<span class="built_in">begin</span>(),stk.<span class="built_in">end</span>(),a[i])=a[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;stk.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>

<p>手写二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tt,stk[N];</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt==<span class="number">0</span>||a[i]&gt;stk[tt]) stk[++tt]=a[i];            <span class="comment">// &gt;=</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=tt;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(stk[mid]&gt;=a[i]) r=mid;                  <span class="comment">// &gt;</span></span><br><span class="line">            <span class="keyword">else</span> l=mid<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[l]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;tt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Dilworth 定理</strong>（将一个序列剖成若干个单调不升子序列的最小个数等于该序列最长上升子序列的个数）。</p>
<p><strong>贪心证明：</strong>从左到右依次枚举每个导弹。假设现在有若干个导弹拦截系统可以拦截它，那么我们肯定选择这些系统当中位置最低的那一个。如果不存在任何一个导弹拦截系统可以拦截它，那我们只能新加一个系统了。</p>
<h2 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h2><p>无特殊说明，$n$：物品数，$m$：背包体积，$f$ 数组需初始化为0。</p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><h4 id="求最大价值"><a href="#求最大价值" class="headerlink" title="求最大价值"></a>求最大价值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,v[N],w[N],f[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j]：前i个物品体积不超过j时的最大价值</span></span><br><span class="line"><span class="comment">不选第i个物品：f[i][j]=f[i-1][j];</span></span><br><span class="line"><span class="comment">选第i个物品：  f[i][j]=max(f[i-1][j-v[i]]+w[i],f[i-1][j]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">        f[j]=<span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[m];</span><br></pre></td></tr></table></figure>

<p>恰好装满：$f$ 数组初始化为负无穷，$f[0][0]&#x3D;0$ 。</p>
<h4 id="求方案数"><a href="#求方案数" class="headerlink" title="求方案数"></a>求方案数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,v[N],f[N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j]：前i个物品恰好装满j体积的方案数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i];</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">        f[j]+=f[j-v[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[m];</span><br></pre></td></tr></table></figure>

<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包每件物品可以选无限次</p>
<h4 id="求最大价值-1"><a href="#求最大价值-1" class="headerlink" title="求最大价值"></a>求最大价值</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,v[N],w[N],f[N][N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j]：前i个物品体积不大于j的最大价值</span></span><br><span class="line"><span class="comment">选k个i：f[i][j]=f[i-1][j-k*v[i]]+k*w[i]</span></span><br><span class="line"><span class="comment">优化：f[i][j]=max(f[i-1][j],f[i][j-v[i])+w[i];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">        f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=v[i]) f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n][m];</span><br></pre></td></tr></table></figure>

<h4 id="求方案数-1"><a href="#求方案数-1" class="headerlink" title="求方案数"></a>求方案数</h4><p>&#x2F;&#x2F; $f[i][j]+&#x3D;f[i][j-k*a[i]]$</p>
<p>注意初始化 $f[i][0]&#x3D;1$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,v[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,f[<span class="number">10</span>][<span class="number">11000</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j]：前i个物品恰好装满j的方案数</span></span><br><span class="line"><span class="comment">选k个i：f[i][j]+=f[i-1][j-k*v[i]]</span></span><br><span class="line"><span class="comment">优化：f[i][j]=f[i-1][j]</span></span><br><span class="line"><span class="comment">    f[i][j]+=f[i][j-v[i]];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;=v[i]) f[j]+=f[j-v[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><h4 id="2进制优化"><a href="#2进制优化" class="headerlink" title="2进制优化"></a>2进制优化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先将每个物品的s个分成2进制；</span></span><br><span class="line"><span class="comment">然后用01背包：f[i][j] = max(f[i-1][j], f[i-1][j-v[i]]+w[i]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>,n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a,b,s,k=<span class="number">1</span>;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;s;</span><br><span class="line">    <span class="keyword">while</span>(s&gt;=k)&#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        v[cnt]=a*k;</span><br><span class="line">        w[cnt]=b*k;</span><br><span class="line">        s=s-k;</span><br><span class="line">        k=k&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s)&#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        v[cnt]=a*s;</span><br><span class="line">        w[cnt]=b*s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=v[i];j--)&#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j-v[i]]+w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n,m,k=<span class="number">100</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">110</span>],w[<span class="number">110</span>],<span class="built_in">f</span>(N);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j]：前i组花费j价格的最大价值</span></span><br><span class="line"><span class="comment">f[i][j]=max(f[i-1][j],f[i-1][j-v[i][1]]+w[i][1],f[i-1][j-v[i][2]]+w[i][2]...);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f[j]=max(f[j],f[j-v[i][1]]+w[i][1],f[j-v[i][2]]+w[i][2]...);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		v[c].<span class="built_in">push_back</span>(a);</span><br><span class="line">		w[c].<span class="built_in">push_back</span>(b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=m;j;j--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;v[i].<span class="built_in">size</span>();q++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(j&gt;=v[i][q]) f[j]=<span class="built_in">max</span>(f[j],f[j-v[i][q]]+w[i][q]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;f[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><p><a href="https://www.luogu.com.cn/article/tzeo544s">数字组成的奥妙——数位dp</a></p>
<p>f 数组在允许的情况下，尽可能表示出所有参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意开long long</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>],f[<span class="number">20</span>][<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos,<span class="type">int</span> lead,<span class="type">int</span> limit,<span class="type">int</span> sum,<span class="type">int</span> x)</span></span>&#123;       <span class="comment">//如果有次数，统计下来</span></span><br><span class="line">	<span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> sum;</span><br><span class="line">	<span class="keyword">if</span>(!limit&amp;&amp;!lead&amp;&amp;f[pos][sum][x]!=<span class="number">-1</span>) <span class="keyword">return</span> f[pos][sum][x];</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> maxd=limit?a[pos]:<span class="number">9</span>;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=maxd;i++)&#123;      <span class="comment">//注意：枚举每一位数字，不要漏情况</span></span><br><span class="line">		<span class="type">int</span> summ=sum;              <span class="comment">//注意：summ对每个i应是独立的</span></span><br><span class="line">		<span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;i==<span class="number">0</span>&amp;&amp;!lead) summ++;</span><br><span class="line">		<span class="keyword">if</span>(x!=<span class="number">0</span>&amp;&amp;x==i) summ++;</span><br><span class="line">		ans+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>,lead&amp;&amp;i==<span class="number">0</span>,limit&amp;&amp;i==maxd,summ,x);    <span class="comment">//limit&amp;&amp;i==maxd 改为 limit&amp;&amp;i==a[pos]</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!limit&amp;&amp;!lead) f[pos][sum][x]=ans;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果取模的话</span></span><br><span class="line">cout&lt;&lt;(<span class="built_in">cal</span>(r)-<span class="built_in">cal</span>(l<span class="number">-1</span>)+mod)%mod;</span><br></pre></td></tr></table></figure>

<p>例题：</p>
<p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=2089">Problem - 2089 (hdu.edu.cn)</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2602">数字计数 - 洛谷 </a></p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。</p>
<p>在记忆化搜索中，当算法需要计算某个子问题的结果时，它首先检查是否已经计算过该问题。</p>
<p>如果已经计算过，则直接返回已经存储的结果；否则，计算该问题，并将结果存储下来以备将来使用。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p>比如「斐波那契数列」的定义是： $$f(0)&#x3D;0,f(1)&#x3D;1,f(n)&#x3D;f(n−1)+f(n−2)$$ 。</p>
<p>如果我们使用递归算法求解第 $n$ 个斐波那契数，则对应的递推过程如下：</p>
<p><img data-src="D:\图片_typora\001.png"></p>
<p>从图中可以看出：如果使用普通递归算法，想要计算 $f(5)$ ，需要先计算 $f(3)$ 和 $f(4)$，而在计算 $f(4)$ 时还需要计算 $f(3)$。这样 $f(3)$ 就进行了多次计算，同理 $f(0)$、$f(1)$、$f(2)$ 都进行了多次计算，从而导致了重复计算问题。时间复杂度为 $O(2^n)$ 。</p>
<p>而记忆化搜索可以避免重复搜索，大大提高了效率。时间复杂度为 $O(n)$ 。</p>
<p>「斐波那契数列」的记忆化代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[n]) <span class="keyword">return</span> f[n];        <span class="comment">//记忆化</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	f[n] = <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> f[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">fib</span>(n) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h4><p> <a href="https://www.luogu.com.cn/problem/P1434">此处为题面</a></p>
<p>先想普通 $dfs$，因为没有要求起点、终点，所以每个点 $dfs$ 一次，$dfs(i , j)$ 含义是：以 $[i , j]$ 为起点的最长路径（不包含起点）。</p>
<p>如果 某个点 $[x , y]$ 的周围有比它小的点 $[xx , yy]$ ，说明 $[x , y]$ 可以到达 $[xx , yy]$ ，对 $[xx , yy]$ 进行$dfs$，更新 $[x , y]$的最长路径。</p>
<p>但是会超时，于是用记忆化优化，用 $f[i , j]$ 存下来以 $[i , j]$ 为起点的最长路径，下次搜到 $[i , j]$ 时不用继续往下搜了，直接返回 $f[i , j]$ 。</p>
<p>记忆化搜索每个点只会向下递归1次，所以时间复杂度是 $O(r*c)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>][<span class="number">1010</span>], f[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> r, c, ma;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x][y]) <span class="keyword">return</span> f[x][y];         <span class="comment">//记忆化</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span> &#125;, dy[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">            <span class="comment">//如果在范围内且比当前位置低，就递归</span></span><br><span class="line">            <span class="keyword">if</span> (xx &gt; <span class="number">0</span> &amp;&amp; xx &lt;= r &amp;&amp; yy &gt; <span class="number">0</span> &amp;&amp; yy &lt;= c &amp;&amp; a[xx][yy] &lt; a[x][y]) &#123;</span><br><span class="line">                f[x][y] = <span class="built_in">max</span>(f[x][y], <span class="built_in">dfs</span>(xx,yy) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= c; j++) &#123;</span><br><span class="line">            ma = <span class="built_in">max</span>(ma, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ma + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="记忆化搜索与递推区别"><a href="#记忆化搜索与递推区别" class="headerlink" title="记忆化搜索与递推区别"></a>记忆化搜索与递推区别</h3><ul>
<li><p><a href="https://www.luogu.com.cn/article/qay8mori">聊聊动态规划与记忆化搜索</a></p>
<p>「记忆化搜索」与「递推」都是动态规划的实现方式，但是两者之间有一些区别。</p>
<p><strong>记忆化搜索</strong>：「自顶向下」的解决问题，采用自然的递归方式编写过程，在过程中会保存每个子问题的解来避免重复计算。</p>
<ul>
<li><p>优点：1. 处理边界简单</p>
<p>​			2. 某些题想状态转移方程更简单</p>
<p>​            3. 可以剪枝</p>
</li>
<li><p>缺点：1. 可能会因为递归深度过大而导致栈溢出问题，同时递归比递推效率慢</p>
<p>​			2. 一些时间空间优化手段很难加</p>
</li>
</ul>
<p><strong>递推</strong>：「自底向上」的解决问题，采用循环的方式编写过程，在过程中通过保存每个子问题的解来避免重复计算。</p>
<ul>
<li>优点：1. 不存在栈溢出问题。 2. 效率更高。</li>
<li>缺点：有些状态转移方程非常复杂，递推公式不好想。</li>
</ul>
</li>
</ul>
<h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>注意 $len&#x3D;2$ 的时候， $f[i+1][j-1]$可能无意义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=i+len<span class="number">-1</span>;j&lt;=<span class="number">2</span>*n;i++,j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=len<span class="number">-2</span>;k++)&#123;</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i][j],f[i][i+k]+f[i+k][j]+a[i]*a[i+k]*a[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="换根dp"><a href="#换根dp" class="headerlink" title="换根dp"></a>换根dp</h2><p>$up$ ：向上走的最大距离。</p>
<p>$dn1$ ：向下走的最大距离。</p>
<p>$dn2$ ：向下走的次大距离（不走 $dn1$ 的最大距离）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; g[N];</span><br><span class="line"><span class="type">int</span> n,mi=<span class="number">0x3f3f3f3f</span>,up[N],dn1[N],dn2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[u])&#123;</span><br><span class="line">        <span class="type">int</span> f=i.first,s=i.second;</span><br><span class="line">        <span class="keyword">if</span>(f==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(f,u);</span><br><span class="line">        <span class="keyword">if</span>(dn1[f]+s&gt;=dn1[u])&#123;</span><br><span class="line">            dn2[u]=dn1[u];</span><br><span class="line">            dn1[u]=dn1[f]+s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dn2[u]=<span class="built_in">max</span>(dn2[u],dn1[f]+s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:g[u])&#123;</span><br><span class="line">        <span class="type">int</span> f=i.first,s=i.second;</span><br><span class="line">        <span class="keyword">if</span>(f==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(dn1[u]==dn1[f]+s)&#123;</span><br><span class="line">            up[f]=<span class="built_in">max</span>(up[u]+s,dn2[u]+s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            up[f]=<span class="built_in">max</span>(up[u]+s,dn1[u]+s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs2</span>(f,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(x &amp; (x &gt;&gt; <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __builtin_popcount(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">f[i][j][state]: 前i行，总共用j个棋子，第i行是state的方案数</span></span><br><span class="line"><span class="comment">f[i][j][state]+=f[i-1][j-count(state)][pre[state]];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; pre[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">12</span>][<span class="number">120</span>][<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(i)) state.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : state) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : state) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(i &amp; j) &amp;&amp; (<span class="built_in">check</span>(i | j))) pre[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u : state) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : pre[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="built_in">count</span>(u) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        f[i][j][u] += f[i - <span class="number">1</span>][j - <span class="built_in">count</span>(u)][v];</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; f[i][j][u] &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n + <span class="number">1</span>][k][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>蒙德里安的梦想</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    bitset&lt;12&gt;<span class="built_in">b</span>(x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!b[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!b[i + <span class="number">1</span>]) b[i] = b[i + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b[m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n &amp;&amp; m) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;((<span class="number">1</span> &lt;&lt; m) + <span class="number">3</span>));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">((<span class="number">1</span> &lt;&lt; m) + <span class="number">3</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; pre[(<span class="number">1</span> &lt;&lt; m) + <span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) <span class="keyword">if</span> (<span class="built_in">check</span>(i, m)) st[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; m); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (st[i | j] &amp;&amp; ((i &amp; j) == <span class="number">0</span>)) pre[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">0</span>; u &lt; (<span class="number">1</span> &lt;&lt; m); u++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> v : pre[u]) &#123;</span><br><span class="line">                    f[i][u] += f[i - <span class="number">1</span>][v];</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; &quot; &quot; &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; f[i - 1][v] &lt;&lt; &quot;-&gt;&quot; &lt;&lt; f[i][u] &lt;&lt; &quot;++\n&quot;;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; f[n][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// cin &gt;&gt; T;</span></span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/11/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>字符串 &amp; 输入输出</title>
    <url>/2024/11/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%20&amp;%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>字符串</p>
<span id="more"></span>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p><code>scanf</code> 读字符时会读入空格、换行</p>
<p><code>scanf</code> 读字符串时不会读入空格、换行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c,cc;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;c&gt;&gt;cc;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%c%c&quot;</span>,&amp;x,&amp;c,&amp;cc);</span><br><span class="line">cout&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cc;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><p><code>cin</code> 不会读入开始的换行、空格，遇到空格、换行停止</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//char s[1000];</span></span><br><span class="line"><span class="comment">//char s;</span></span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br></pre></td></tr></table></figure>

<h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h3><p><code>getchar</code> 会读入换行和空格，但是不能与IOS同时使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br></pre></td></tr></table></figure>

<h3 id="ignore"><a href="#ignore" class="headerlink" title="ignore()"></a>ignore()</h3><p>从输入流中移除（忽略）下一个字符</p>
<p>如果计数值达到 $a$ 或者被抛弃的字符是 $ch$ ，则 <code>cin.ignore()</code> 函数执行终止；否则，它继续等待。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line">cin.<span class="built_in">ignore</span>(a,ch)</span><br></pre></td></tr></table></figure>

<h3 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h3><p>读入一行字符串，遇到换行停止。使用前一般先清除缓存区换行符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></table></figure>

<p><strong>清除缓存区换行方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">ignore</span>();</span><br><span class="line"><span class="built_in">getchar</span>();      <span class="comment">//不能与IOS同时使用。</span></span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br></pre></td></tr></table></figure>

<h3 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h3><p><code>stringstream</code> 可以逐个读取单词（或更准确地说，是由空白字符分隔的字符串序列）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin,s);</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;   <span class="comment">//将ss初始化为s</span></span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">while</span>(ss&gt;&gt;str)&#123;       <span class="comment">//逐个读取单词，读取到str中</span></span><br><span class="line">    cout&lt;&lt;str&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">八进制: %o</span><br><span class="line">十六进制: %x</span><br></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><a href="https://blog.csdn.net/fdqw_sph/article/details/54233971">c++中的string常用函数用法总结_c++string函数-CSDN博客</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(num,c)</span> <span class="comment">//生成一个字符串，包含num个c字符</span></span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(str,\stridx,\strlen)</span> <span class="comment">//将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</span></span></span><br></pre></td></tr></table></figure>

<h3 id="插入-删除字符-串"><a href="#插入-删除字符-串" class="headerlink" title="插入&#x2F;删除字符 (串)"></a>插入&#x2F;删除字符 (串)</h3><p><code>insert (index, count, ch)</code> 和 <code>insert (index, str)</code> 是比较常见的插入函数。它们分别表示在 <code>index</code> 处连续插入 <code>count</code> 次字符串 $ch$ 和插入字符串 $str$ 。时间复杂度 $O(|s|-index+count)$ 。</p>
<p><code>erase(index, count)</code> 函数将字符串 <code>index</code> 位置开始 (含) 的 <code>count</code> 个字符删除（若不传参给 <code>count</code> 则表示删去 <code>index</code> 位置及以后的所有字符）。</p>
<h2 id="字符串整数互换"><a href="#字符串整数互换" class="headerlink" title="字符串整数互换"></a>字符串整数互换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">num = std::<span class="built_in">stoi</span>(str)   <span class="comment">// string -&gt; int</span></span><br><span class="line">num = std::<span class="built_in">stoll</span>(str)   <span class="comment">// string -&gt; long long</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;456&quot;</span>;</span><br><span class="line"><span class="type">int</span> num = std::<span class="built_in">atoi</span>(str);   <span class="comment">// char -&gt; int</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">std::string str = <span class="built_in">to_string</span>(num); <span class="comment">// int -&gt; string</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>图论</title>
    <url>/2024/11/25/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<p><span style='color:red;background:背景颜色;font-size:20;font-family:;'>注意输入时是否有重边或自环</span></p>
<p><span style='color:red;background:背景颜色;font-size:20;font-family:;'>注意是有向图 还是 无向图</span></p>
<span id="more"></span>

<p>无环图用dfs也会TLE，用记忆化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>-&gt;<span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>-&gt;<span class="number">3</span>)</span><br><span class="line">(<span class="number">2</span>-&gt;<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>-&gt;<span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>-&gt;<span class="number">5</span>)</span><br><span class="line">(<span class="number">4</span>-&gt;<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这个时候你最后一个节点 $n$ 将会访问 $2^{(\frac{n}{3})}$ 次。</p>
<h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><p>简单图：无重边，无自环</p>
<h2 id="负环"><a href="#负环" class="headerlink" title="负环"></a>负环</h2><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;PII&gt; g[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">2010</span>], ans[<span class="number">2010</span>], st[<span class="number">2010</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//u所在的连通图有没有负环</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (ans[u] || flag) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(u);</span><br><span class="line">	st[u]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> top = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		st[top] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (PII i : g[top]) &#123;</span><br><span class="line">			<span class="type">int</span> f = i.first, s = i.second;</span><br><span class="line">			<span class="keyword">if</span> (dist[f] &gt; s + dist[top]) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!st[f]) &#123;</span><br><span class="line">					st[f] = <span class="number">1</span>;</span><br><span class="line">					q.<span class="built_in">push</span>(f);</span><br><span class="line">				&#125;</span><br><span class="line">				ans[f] = ans[top] + <span class="number">1</span>;</span><br><span class="line">				dist[f] = s + dist[top];</span><br><span class="line">				<span class="keyword">if</span> (ans[f] &gt; n) &#123;</span><br><span class="line">					flag = <span class="number">1</span>;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化： memset(dist,0x3f,sizeof dist);</span></span><br><span class="line">vector&lt;PII&gt; g[<span class="number">20010</span>];</span><br><span class="line"><span class="type">int</span> flag,n,m;</span><br><span class="line"><span class="type">int</span> st[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="keyword">return</span> ;</span><br><span class="line">    st[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(PII i:g[x])&#123;</span><br><span class="line">        <span class="type">int</span> y=i.first,z=i.second;</span><br><span class="line">        <span class="keyword">if</span>(dist[y]&gt;dist[x]+z)&#123;</span><br><span class="line">            dist[y]=dist[x]+z;</span><br><span class="line">            <span class="keyword">if</span>(st[y])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="单源最短路"><a href="#单源最短路" class="headerlink" title="单源最短路"></a>单源最短路</h3><h4 id="dijkstra"><a href="#dijkstra" class="headerlink" title="dijkstra"></a>dijkstra</h4><p>每次找离集合 $1$ 最近的点，加进集合，用这个点更新其他点。</p>
<p>边的的权值不能是负的。</p>
<p>稀疏图，时间复杂度 $O(mlogn)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> st[N], m, n, dist[N];</span><br><span class="line">vector&lt;PII&gt; g[N];</span><br><span class="line"><span class="type">int</span> ff[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; pq;</span><br><span class="line">	pq.<span class="built_in">push</span>(&#123; <span class="number">0</span>,<span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		PII top = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> f = top.first, s = top.second;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (st[s]) <span class="keyword">continue</span>;</span><br><span class="line">        st[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> i : g[s]) &#123;</span><br><span class="line">			<span class="keyword">if</span> (dist[i.first] &gt; f + i.second) &#123;</span><br><span class="line">				dist[i.first] = f + i.second;</span><br><span class="line">				pq.<span class="built_in">push</span>(&#123; dist[i.first],i.first &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h4><p>边的权值可以是负的。</p>
<p>时间复杂的 $O(n*m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dist[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dist2[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,d;</span><br><span class="line">&#125;e[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dist2[i]=dist[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="type">int</span> a=e[j].a,b=e[j].b,d=e[j].d;</span><br><span class="line">            dist[b]=<span class="built_in">min</span>(dist[b],dist2[a]+d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h4><p>可以有负权边，不能有负权回路。</p>
<p>时间复杂度最坏 $O(n*m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;PII&gt; g[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(PII i:g[t])&#123;</span><br><span class="line">            <span class="type">int</span> f=i.first,s=i.second;</span><br><span class="line">            <span class="keyword">if</span>(dist[f]&gt;dist[t]+s)&#123;</span><br><span class="line">                dist[f]=dist[t]+s;</span><br><span class="line">                <span class="keyword">if</span>(!st[f])&#123;</span><br><span class="line">                    st[f]=<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>) cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多源最短路"><a href="#多源最短路" class="headerlink" title="多源最短路"></a>多源最短路</h3><h4 id="floyd"><a href="#floyd" class="headerlink" title="floyd"></a>floyd</h4><p>时间复杂度 $O(n^3)$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[<span class="number">210</span>][<span class="number">210</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化：memset(g,0x3f,sizeof g);</span></span><br><span class="line"><span class="comment">//for(int i=1;i&lt;=n;i++) g[i][i]=0;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                g[i][j]=<span class="built_in">min</span>(g[i][k]+g[k][j],g[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if(g[x][y]&gt;=0x3f3f3f3f/2) cout&lt;&lt;&quot;impossible\n&quot;;</span></span><br></pre></td></tr></table></figure>

<h3 id="分层最短路"><a href="#分层最短路" class="headerlink" title="分层最短路"></a>分层最短路</h3><p><a href="https://www.luogu.com.cn/problem/P4568">飞行路线 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P4822">冻结 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2939">Revamping Trails G - 洛谷</a></p>
<hr>
<ul>
<li><strong>定义</strong></li>
</ul>
<p>分层图最短路是指在可以进行分层图的图上解决最短路问题。分层图：可以理解为有多个平行的图。</p>
<p>一般模型是：在一个正常的图上可以进行 $k$ 次决策，对于每次决策，不影响图的结构，只影响目前的状态或代价。一般将决策前的状态和决策后的状态之间连接一条权值为决策代价的边，表示付出该代价后就可以转换状态了。</p>
<hr>
<ul>
<li><strong>分层图有两种做法：</strong></li>
</ul>
<ol>
<li><p><strong>建图时建成k+1层</strong></p>
<p>我们建 $k+1$ 层图。然后有边的两个点，多建一条到下一层边权为 $0$ 的单向边，如果走了这条边就表示用了一次机会。</p>
<p>有 $N$ 个点时，$1-n$表示第一层，$(1+n)-(n+n)$代表二层，$(1+2 * n)-( n +2 * n)$代表第三层，$(1+i * n)-(n+i * n)$代表第$i+1$层。因为要建$k+1$层图，数组要开到 $n * ( k + 1)$，点的个数也为 $n * ( k + 1 )$ 。</p>
</li>
<li><p><strong>多开一维记录机多开一维记录机会信息。会多开一维记录机会信息。</strong></p>
<p>我们把 $dist$ 数组和 $st$ 数组多开一维记录 $k$ 次机会的信息。</p>
<p>$dis[i][j]$ 代表到达 $i$ 用了 $j$ 次免费机会的最小花费.<br>$st[i][j]$ 代表到达 $i$ 用了 $j$ 次免费机会的情况是否出现过.<br>更新的时候先更新同层之间（即花费免费机会相同）的最短路，然后更新从该层到下一层（即再花费一次免费机会）的最短路。</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOS ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100000</span>;</span><br><span class="line">vector&lt;PII&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j, k, n, m, s, t;</span><br><span class="line"><span class="type">int</span> st[N + <span class="number">10</span>][<span class="number">15</span>];</span><br><span class="line"><span class="type">int</span> dist[N + <span class="number">10</span>][<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> v, w, cnt;</span><br><span class="line">	<span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> v, <span class="type">int</span> w, <span class="type">int</span> cnt) : <span class="built_in">v</span>(v), <span class="built_in">w</span>(w), <span class="built_in">cnt</span>(cnt) &#123;&#125;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node&amp; a) <span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (cnt == a.cnt) &#123;</span><br><span class="line">			<span class="keyword">return</span> w &gt; a.w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cnt &gt; a.cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	priority_queue&lt;node&gt; pq;</span><br><span class="line">	dist[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	pq.<span class="built_in">push</span>(<span class="built_in">node</span>(s, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		node top = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (st[top.v][top.cnt]) <span class="keyword">continue</span>;</span><br><span class="line">		st[top.v][top.cnt] = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (PII i : g[top.v]) &#123;</span><br><span class="line">			<span class="type">int</span> f = i.first, s = i.second;</span><br><span class="line">			<span class="keyword">if</span> (dist[f][top.cnt] &gt; top.w + s) &#123;</span><br><span class="line">				dist[f][top.cnt] = top.w + s;</span><br><span class="line">				pq.<span class="built_in">push</span>(<span class="built_in">node</span>(f, dist[f][top.cnt], top.cnt));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (top.cnt &lt; k &amp;&amp; dist[f][top.cnt + <span class="number">1</span>] &gt; top.w) &#123;</span><br><span class="line">				dist[f][top.cnt + <span class="number">1</span>] = top.w;</span><br><span class="line">				pq.<span class="built_in">push</span>(<span class="built_in">node</span>(f, dist[f][top.cnt + <span class="number">1</span>], top.cnt + <span class="number">1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	IOS;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">		<span class="type">int</span> a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		g[a].<span class="built_in">push_back</span>(&#123; b,c &#125;);</span><br><span class="line">		g[b].<span class="built_in">push_back</span>(&#123; a,c &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dijkstra</span>();</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">		ans = <span class="built_in">min</span>(ans, dist[t][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; dist[t][k];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="差分与约束"><a href="#差分与约束" class="headerlink" title="差分与约束"></a>差分与约束</h3><p><a href="https://www.luogu.com.cn/problem/P1993">小 K 的农场 - 洛谷</a></p>
<p><a href="https://www.luogu.com.cn/problem/P5960">【模板】差分约束 - 洛谷</a></p>
<hr>
<ul>
<li><strong>概念</strong></li>
</ul>
<p>如果一个系统由 $n$ 个变量和 $m$ 个约束条件组成，形成 $m$ 个形如 $x_i - x_j ≤  k$  的不等式，则称其为差分约束系统。</p>
<hr>
<ul>
<li><strong>过程</strong></li>
</ul>
<p>设 $dist[0]&#x3D;0$ 并向每一个点连一条权重为 $0$ 边，跑单源最短路，若图中存在负环，则给定的差分约束系统无解，否则 $x_i &#x3D; dist[i]$ 为该差分约束系统的一组解。</p>
<hr>
<ul>
<li><strong>常用变形技巧</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="center">题意</th>
<th align="center">转化</th>
<th align="center">连边</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$x_i - x_j &lt;&#x3D; k$</td>
<td align="center">$x_i &lt;&#x3D; x_j + k$</td>
<td align="center">$add(x_j，x_i，k)$</td>
</tr>
<tr>
<td align="center">$x_i - x_j &lt; k$</td>
<td align="center">$x_i &lt;&#x3D; x_j + k - 1$</td>
<td align="center">$add(x_j，x_i，k - 1)$</td>
</tr>
<tr>
<td align="center">$x_i &#x3D; x_j$</td>
<td align="center">$x_i &lt;&#x3D; x_j , x_j &lt;&#x3D; x_i$</td>
<td align="center">$add(x_i，x_j，0)，add(x_j，x_i，0)$</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><strong>代码</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j, k, n, m, s, t, flag;</span><br><span class="line">vector&lt;PII&gt; g[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dist[<span class="number">5010</span>], ans[<span class="number">5010</span>], st[<span class="number">5010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(u);</span><br><span class="line">	dist[u] = <span class="number">0</span>;</span><br><span class="line">	st[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		<span class="type">int</span> top = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		st[top] = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (PII i : g[top]) &#123;</span><br><span class="line">			<span class="type">int</span> f = i.first, s = i.second;</span><br><span class="line">			<span class="keyword">if</span> (dist[f] &gt; dist[top] + s) &#123;</span><br><span class="line">				dist[f] = dist[top] + s;</span><br><span class="line">				ans[f] = ans[top] + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (!st[f]) &#123;</span><br><span class="line">					q.<span class="built_in">push</span>(f);</span><br><span class="line">					st[f] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (ans[f] &gt; n + <span class="number">10</span>) &#123;</span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">		g[b].<span class="built_in">push_back</span>(&#123; a,c &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) g[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123; i,<span class="number">0</span> &#125;);</span><br><span class="line">	<span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">			cout &lt;&lt; dist[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>每次找离当前生成树最小的点，加进生成树中</p>
<p>稠密图，时间复杂度 $O(n^2)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line"><span class="type">int</span> st[<span class="number">510</span>],d[<span class="number">510</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//memset(g,0x3f,sizeof g);</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||d[t]&gt;d[j])) t=j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d[t]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        </span><br><span class="line">        st[t]=<span class="number">1</span>;</span><br><span class="line">        ans+=d[t];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            d[j]=<span class="built_in">min</span>(d[j],g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>所有边排序，如果当前边的两个端点不连通，将边加进生成树里，连接俩个端点。</p>
<p>稀疏图，时间复杂度 $O(mlogm)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.w&lt;b.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x!=p[x]) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e<span class="number">+1</span>+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> fa=<span class="built_in">find</span>(e[i].u),fb=<span class="built_in">find</span>(e[i].v);</span><br><span class="line">        <span class="keyword">if</span>(fa!=fb)&#123;</span><br><span class="line">            p[fa]=fb;</span><br><span class="line">            res+=e[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) cout&lt;&lt;res&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h3><p><img data-src="https://cdn.acwing.com/media/article/image/2022/03/28/55289_ac17cbdcae-%E4%BA%8C%E5%88%86%E5%9B%BE.png#=100*100" alt="二分图 -w150"></p>
<ul>
<li>开始对任意一未染色的顶点染色。</li>
<li>判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色。</li>
<li>若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    ans[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:g[t])&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="number">-1</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                ans[i]=(ans[t]<span class="number">+1</span>)%<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ans[i]==ans[t])&#123;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans[i]==<span class="number">-1</span>) <span class="built_in">bfs</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>二分图的匹配：给定一个二分图 $G$，在 $G$ 的一个子图 $M$ 中，$M$ 的边集 $$ 中的任意两条边都不依附于同一个顶点，则称 $M$ 是一个匹配。</p>
<p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p>
<p>$st$ 的理解可以参考操作系统中锁的概念。假如说左边的是进程，右边的是资源。当进程 $i$ 要访问资源 $j$ 时，为了避免其他进程在此时访问资源 $j$ ，需要对资源 $j$ 加一个“锁”，即 $st[j] &#x3D; true$ 。当进程 $i$ 访问完资源时，为了让后续其他进程也能访问资源，需要把锁解开，即 $memset(st, false, sizeof st)$ 。时间复杂度 $O(n*m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以有重边</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:g[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            st[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[i]==<span class="number">0</span>||<span class="built_in">find</span>(match[i]))&#123;</span><br><span class="line">                match[i]=x;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st,<span class="number">0</span>,<span class="keyword">sizeof</span> st);    <span class="comment">//每次应初始化st数组</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(i)) ans++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h2><h3 id="四色定理"><a href="#四色定理" class="headerlink" title="四色定理"></a>四色定理</h3><p>对于任何一个平面图，一定可以用四种颜色，对它的结点进行着色，使得邻接的结点都有不同的颜色。</p>
<p><strong>对点着色的鲍威尔方法：</strong></p>
<p>第一步：对每个结点按度数递减次序进行排列(相同度数的结点次序可随意)</p>
<p>第二步：用第一种颜色对第一个结点着色，并按次序对与前面着色点不相邻的每一点着同样的颜色。</p>
<p>第三步：用第二种颜色对未着色的点重复第二步，用第三种颜色继续这种做法，直到全部点均着了色为止。</p>
<h2 id="最长路"><a href="#最长路" class="headerlink" title="最长路"></a>最长路</h2><p>最长路距离初始化为负无穷</p>
<h3 id="无环图"><a href="#无环图" class="headerlink" title="无环图"></a>无环图</h3><ul>
<li><p>两点之间最长路：floyd、spfa边改成负的</p>
</li>
<li><p>整个图的最长路：看成树做dp</p>
<p>时间复杂度 $O(n+m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//本代码求的是缩完点后可以经过的最多点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[u]) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i:gg[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[u]=ans+Size[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=scc_cnt;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    ma=<span class="built_in">max</span>(ma,f[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拓扑+dp（可以求两点之间，可以求全图）</p>
<p>时间复杂度 $O(n+m)$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1到n的最长路</span></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; g[N];</span><br><span class="line"><span class="type">int</span> in[N],f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=<span class="number">-0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">	f[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i:g[t])&#123;</span><br><span class="line">			f[i.f]=<span class="built_in">max</span>(f[i.f],f[t]+i.s);</span><br><span class="line">			in[i.f]--;</span><br><span class="line">			<span class="keyword">if</span>(!in[i.f]) q.<span class="built_in">push</span>(i.f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(f[n]&lt;=<span class="number">-1e15</span>) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;f[n]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="有环图"><a href="#有环图" class="headerlink" title="有环图"></a>有环图</h3><ul>
<li><p>$tarjan$ 缩点成无环图</p>
</li>
<li><p>拓扑排序+ $dfs$</p>
<p>暂时不会 … …</p>
</li>
</ul>
<h2 id="联通性问题"><a href="#联通性问题" class="headerlink" title="联通性问题"></a>联通性问题</h2><h3 id="DFS-生成树"><a href="#DFS-生成树" class="headerlink" title="DFS 生成树"></a>DFS 生成树</h3><p>在介绍该算法之前，先来了解 DFS 生成树，我们以下面的有向图为例:</p>
<p>有向图的 DFS 生成树主要有 4 种边（不一定全部出现）：</p>
<p><img data-src="https://oi-wiki.org/graph/images/dfs-tree.svg" alt="DFS 生成树"></p>
<ol>
<li>树边（tree edge）：示意图中以黑色边表示，每次搜索找到一个还没有访问过的结点的时候就形成了一条树边。</li>
<li>反祖边（back edge）：示意图中以红色边表示（即 $7 \rightarrow 1$ ），也被叫做回边，即指向祖先结点的边。</li>
<li>横叉边（cross edge）：示意图中以蓝色边表示（即 $9 \rightarrow 7$ ），它主要是在搜索的时候遇到了一个已经访问过的结点，但是这个结点并不是 当前结点的祖先。</li>
<li>前向边（forward edge）：示意图中以绿色边表示 （即 $3 \rightarrow 6$ ），它是在搜索的时候遇到子树中的结点的时候形成的。</li>
</ol>
<h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h3><ul>
<li>$dfn$：时间戳，是指一个节点被深度优先搜索到（被第一次访问、进入搜索树）的顺序。</li>
<li>$low$：指 $u$ 出发，可以经过任意多条树边，最多经过一条非树边，到达的最小的时间戳。</li>
</ul>
<p><a href="https://blog.csdn.net/elijahqi/article/details/80614953">else if里为什么是dfn</a></p>
<h4 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h4><p>逆序是拓扑序</p>
<p>对于一个连通分量图，我们很容易想到，在该连通图中有且仅有一个 $u$ 使得 $d f n_u&#x3D;l o w_u$ 。该结点一定是在深度遍历的过程中，该连通</p>
<p>分量中第一个被访问过的结点，因为它的 $dfn$ 和 $low$ 值最小，不会被该连通分量中的其他结点所影响。</p>
<p>因此，在回溯的过程中，判定 $d f n_u&#x3D;l o w_u$ 是否成立，如果成立，则栈中 $u$ 及其上方的结点构成一个 SCC。</p>
<p>问：为什么是 <code>else if(in_stk[i])</code> ？</p>
<p>答：… …</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N],gg[N];</span><br><span class="line"><span class="type">int</span> stk[N],in_stk[N],dfn[N],low[N];</span><br><span class="line"><span class="type">int</span> times,scc_cnt,top;</span><br><span class="line"><span class="type">int</span> id[N],Size[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//新图用gg表示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++times;</span><br><span class="line">	stk[++top]=u; in_stk[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:g[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(i);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(in_stk[i]) low[u]=<span class="built_in">min</span>(low[u],dfn[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">		scc_cnt++;</span><br><span class="line">		<span class="type">int</span> y;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			y=stk[top--];</span><br><span class="line">			in_stk[y]=<span class="number">0</span>;</span><br><span class="line">			id[y]=scc_cnt;</span><br><span class="line">			Size[scc_cnt]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j:g[i])&#123;</span><br><span class="line">        <span class="type">int</span> u=id[i],v=id[j];</span><br><span class="line">        <span class="keyword">if</span>(u!=v) gg[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="点双连通分量（割点）"><a href="#点双连通分量（割点）" class="headerlink" title="点双连通分量（割点）"></a>点双连通分量（割点）</h4><p><a href="https://www.luogu.com.cn/problem/P3388">【模板】割点（割顶） - 洛谷</a></p>
<p>对于非根节点 $u$ ，如果存在至少一个子节点 $v$ ，使得 $low[v]&gt;&#x3D;dfn[u]$ ，即不能回到祖先，那么 $u$ 点为割点。</p>
<p>对于根节点，如果有两个及以上的儿子，那么就是割点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],vis[N],times;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">	dfn[u]=low[u]=++times;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:g[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])&#123;</span><br><span class="line">			child++;</span><br><span class="line">			<span class="built_in">tarjan</span>(i,u);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[i]);</span><br><span class="line">			<span class="keyword">if</span>(u!=father&amp;&amp;low[i]&gt;=dfn[u]) vis[u]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> low[u]=<span class="built_in">min</span>(low[u],dfn[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==father&amp;&amp;child&gt;=<span class="number">2</span>) vis[u]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="边双连通分量（桥）"><a href="#边双连通分量（桥）" class="headerlink" title="边双连通分量（桥）"></a>边双连通分量（桥）</h4><p>如果点 $u$ 不走反向边不能到达它上边的节点，那么反向边就是桥。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; g[N];</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],stk[N],top,dcc_cnt,times;</span><br><span class="line"><span class="type">int</span> id[N],Size[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> last)</span></span>&#123;</span><br><span class="line">	dfn[u]=low[u]=++times;</span><br><span class="line">	stk[++top]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i:g[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i.first])&#123;</span><br><span class="line">			<span class="built_in">tarjan</span>(i.first,i.second);</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[i.first]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(i.second!=(last^<span class="number">1</span>)) low[u]=<span class="built_in">min</span>(low[u],dfn[i.first]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line">		dcc_cnt++;</span><br><span class="line">		<span class="type">int</span> y;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			y=stk[top--];</span><br><span class="line">			id[y]=dcc_cnt;</span><br><span class="line">			Size[dcc_cnt]++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(y!=u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">    g[u].<span class="built_in">push_back</span>(&#123;v,i&lt;&lt;<span class="number">1</span>&#125;);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>(&#123;u,i&lt;&lt;<span class="number">1</span>|<span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> j:g[i])&#123;</span><br><span class="line">        <span class="type">int</span> u=id[i],v=id[j.first];</span><br><span class="line">        <span class="keyword">if</span>(u!=v) d[u]++;                <span class="comment">////双向边，每条边出现两次，所以一个点的度数+1就行了，建新图也是如此；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><p>多个点的 LCA 等于这些点中 dfs 序最大和最小两个点的 LCA。</p>
<h3 id="倍增"><a href="#倍增" class="headerlink" title="倍增"></a>倍增</h3><p>预处理 $O(nlogn)$ ，查询 $O(logn)$ 。</p>
<p>树的节点可以不是 $[1,n]$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> parents[N][maxd<span class="number">+3</span>],dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>(u);</span><br><span class="line">	dep[u]=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="type">int</span> t=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i:g[t])&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==parents[t][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">			dep[i]=dep[t]<span class="number">+1</span>;</span><br><span class="line">			parents[i][<span class="number">0</span>]=t;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=maxd;j++)</span><br><span class="line">				parents[i][j]=parents[parents[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">			q.<span class="built_in">push</span>(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[a]&lt;dep[b]) <span class="built_in">swap</span>(a,b);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=maxd;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dep[parents[a][i]]&gt;=dep[b])&#123;</span><br><span class="line">			a=parents[a][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a==b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=maxd;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(parents[a][i]!=parents[b][i])&#123;</span><br><span class="line">			a=parents[a][i];</span><br><span class="line">			b=parents[b][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parents[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h3><p>离线做法，时间复杂度 $O(n+q)$ 。</p>
<p>如果树的结点不是 $[1,n]$ ，需要改变 p 数组的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; query[N];</span><br><span class="line"><span class="type">int</span> p[N],res[N],st[N];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=p[x]) <span class="keyword">return</span> p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	st[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i:g[u])&#123;</span><br><span class="line">		<span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">tarjan</span>(i);</span><br><span class="line">		p[i]=u;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i:query[u])&#123;</span><br><span class="line">		<span class="type">int</span> f=i.first,s=i.second;</span><br><span class="line">		<span class="keyword">if</span>(st[f])&#123;</span><br><span class="line">			res[s]=<span class="built_in">find</span>(f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    query[a].<span class="built_in">push_back</span>(&#123;b,i&#125;);       <span class="comment">// i是第几个询问</span></span><br><span class="line">    query[b].<span class="built_in">push_back</span>(&#123;a,i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">tarjan</span>(s);                <span class="comment">// s是根节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cout&lt;&lt;res[i]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>数论</title>
    <url>/2024/11/25/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<p>数论</p>
<span id="more"></span>

<h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>卡特兰数是一个在组合数学里经常出现的一个数列，它并没有一个具体的意义，却是一个十分常见的数学规律</p>
<p>对卡特兰数的初步理解：有一些操作，这些操作有着一定的限制，如一种操作数不能超过另外一种操作数，或者两种操作不能有交集等，这些操作的合法操作顺序的数量</p>
<p>卡特兰数的前几项为 $ 1,1,2,5,14,42,132,429,1430,4862… $</p>
<p><strong>递归定义</strong></p>
<p>$f_n&#x3D;f_0∗f_{n−1}+f_1∗f_{n−2}+…+f_{n−1}*f_0$，其中 $n≥2$  。</p>
<p><strong>递推关系</strong></p>
<p>$f_n&#x3D;\frac{4n−2}{n+1}f_{n−1}$</p>
<p><strong>通项公式</strong></p>
<p>$f_n&#x3D;\frac{1}{n+1}C^n_{2n}$</p>
<p>经化简后可得</p>
<p>$f_n&#x3D;C^n_{2n}−C^{n−1}_{2n}$</p>
<p>只要我们在解决问题时得到了上面的一个关系，那么你就已经解决了这个问题，因为他们都是卡特兰数列</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>假设非法序列为 A，对应的序列为 B。每个 A 只有一个”<strong>第一个前缀和小于 0 的前缀</strong>“，所以每个 A 只能产生一个 B。而每个 B 想要还原到 A，就需要找到”<strong>第一个前缀和大于 0 的前缀</strong>“，显然 B 也只能产生一个 A。</p>
<p><img data-src="https://pic3.zhimg.com/80/v2-1224b08274913efa2cd7dbb31f8e6262_720w.webp" alt="img"></p>
<p>每个 $\mathrm{B}$ 都有 $\mathrm{n}+1$ 个 $+1$ 以及 $\mathrm{n}-1$ 个 $-1$ ，因此 $\mathrm{B}$ 的数量为 $C_{2 n}^{n+1}$ ，相当于在长度为 $2 \mathrm{n}$ 的序列中找到 $n+1$ 个位置存放 $+1$ 。相应的，非法序列的数量也就等于 $C_{2 n}^{n+1}$ 。</p>
<p>出栈序列的总数量共有 $C_{2 n}^n$ ，因此，合法的出栈序列的数量为 $C_{2 n}^n-C_{2 n}^{n+1}&#x3D;\frac{C_{2 n}^n}{n+1}$ 。<br>此时我们就得到了卡特兰数的通项 $\frac{C_{2 n}^n}{n+1}$ ，至于具体如何计算结果将会在后面进行介绍。</p>
<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><ul>
<li><p>相邻的两个正整数 一定互质</p>
</li>
<li><p>若 $x$ 和 $y$ 互质，那么 $x+y\ (或x-y)$ 和 $x$ 互质，且 $x+y$ 与 $x^n$ 互质 。</p>
</li>
<li><p>除了 $11$ 以外的所有的偶数位回文数都不是素数</p>
<p><img data-src="/../images/0004.png" alt="1"></p>
</li>
</ul>
<h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="comment">//埃氏筛</span></span><br><span class="line"><span class="comment">//用质数去筛掉合数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes1</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[++cnt]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+i;j&lt;=n;j=j+i)&#123;</span><br><span class="line">                st[j]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], isprime[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="comment">//线性筛</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[++cnt] = i, isprime[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;primes[j] * i &lt;= n;j++) &#123; <span class="comment">//n趋于int_max时，用primes[j]&lt;=n/i;</span></span><br><span class="line">            st[primes[j] * i] = <span class="number">1</span>;     <span class="comment">//不管i%primes[j]等不等于0，primes[j]都是primes[j]*i的最小质因子。</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Meissel-Lehmer"><a href="#Meissel-Lehmer" class="headerlink" title="Meissel_Lehmer"></a>Meissel_Lehmer</h3><p>求 $[1,n]$ 内质数的个数。时间复杂度 $O(\sqrt{n})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> i64 = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> div(a, b) (1.0 * (a) / (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> half(x) (((x) - 1) / 2)</span></span><br><span class="line"><span class="function">i64 <span class="title">Meissel_Lehmer</span><span class="params">(i64 n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(n - <span class="number">1</span>, <span class="number">0LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v = <span class="built_in">sqrtl</span>(n);</span><br><span class="line">    <span class="type">int</span> s = (v + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">smalls</span><span class="params">(s)</span>, <span class="title">roughs</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;i64&gt; <span class="title">larges</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; s ; i++) &#123;</span><br><span class="line">        smalls[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; s ; i++) &#123;</span><br><span class="line">        roughs[i] = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; s ; i++) &#123;</span><br><span class="line">        larges[i] = <span class="built_in">half</span>(n / roughs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">skip</span><span class="params">(v + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> pc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p = <span class="number">3</span> ; p &lt;= v ; p += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (skip[p] == <span class="literal">false</span>) &#123;</span><br><span class="line">            i64 q = p * p;</span><br><span class="line">            <span class="keyword">if</span> (q * q &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            skip[p] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = q ; i &lt;= v ; i += <span class="number">2</span> * p) &#123;</span><br><span class="line">                skip[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span> ; k &lt; s ; k++) &#123;</span><br><span class="line">                <span class="type">int</span> i = roughs[k];</span><br><span class="line">                <span class="keyword">if</span> (skip[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> d = <span class="number">1LL</span> * i * p;</span><br><span class="line">                larges[ns] = larges[k] - (d &lt;= v ? larges[smalls[d &gt;&gt; <span class="number">1</span>] - pc] : smalls[<span class="built_in">half</span>(<span class="built_in">div</span>(n, d))]) + pc;</span><br><span class="line">                roughs[ns++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            s = ns;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">half</span>(v), j = (((v / p) - <span class="number">1</span>) | <span class="number">1</span>) ; j &gt;= p ; j -= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> c = smalls[j / <span class="number">2</span>] - pc;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> e = j * p / <span class="number">2</span> ; i &gt;= e ; i--) &#123;</span><br><span class="line">                    smalls[i] -= c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pc++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    larges[<span class="number">0</span>] += <span class="number">1LL</span> * (s + <span class="number">2</span> * (pc - <span class="number">1</span>)) * (s - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span> ; k &lt; s ; k++) &#123;</span><br><span class="line">        larges[<span class="number">0</span>] -= larges[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> L = <span class="number">1</span> ; L &lt; s ; L++) &#123;</span><br><span class="line">        <span class="type">int</span> q = roughs[L];</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = n / q;</span><br><span class="line">        <span class="type">int</span> e = smalls[<span class="built_in">half</span>(m / q)] - pc;</span><br><span class="line">        <span class="keyword">if</span> (e &lt; L + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = L + <span class="number">1</span> ; k &lt;= e ; k++) &#123;</span><br><span class="line">            t += smalls[<span class="built_in">half</span>(<span class="built_in">div</span>(m, roughs[k]))];</span><br><span class="line">        &#125;</span><br><span class="line">        larges[<span class="number">0</span>] += t - <span class="number">1LL</span> * (e - L) * (pc + L - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> larges[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> div</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> half</span></span><br></pre></td></tr></table></figure>

<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="求约数个数"><a href="#求约数个数" class="headerlink" title="求约数个数"></a>求约数个数</h3><h4 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h4><p>时间复杂度最坏 $O(\sqrt{N})$ 。对于合数要快于 $O(\sqrt{N})$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;x;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=x/i;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(x%i==<span class="number">0</span>)&#123;</span><br><span class="line">        h[i]++;</span><br><span class="line">        x=x/i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">1</span>) h[x]++;        <span class="comment">//x有可能是质数</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:h)&#123;</span><br><span class="line">    res=res*(i.second<span class="number">+1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="筛法-1"><a href="#筛法-1" class="headerlink" title="筛法"></a>筛法</h4><p>时间复杂度 $O(N\log_2N)$ 。适用于求 $[1,n]$ 每个数的约束个数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i) f[j]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><h3 id="判断回文数"><a href="#判断回文数" class="headerlink" title="判断回文数"></a>判断回文数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ispal</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n/<span class="number">2</span>;i++) <span class="keyword">if</span>(s[i]!=s[n-i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第n个回文数"><a href="#第n个回文数" class="headerlink" title="第n个回文数"></a>第n个回文数</h3><p>构造第 $n$ 个正回文数，时间复杂度 $(log\ n)$ 。</p>
<p>长度为 $1$ 时，有 $9$ 种构造方式 $(1到9)$ ；长度为 $2$ 时，有 $9$ 种构造方式（只考虑回文串的前半段，且没有前导 $0$ ）；长度为 $3$ 时，构造回文串的前两个位，第一位有 $9$ 种选择 $(1到9)$ ，第二位有 $10$ 种 $(0到9)$ …… 长度为6时，构造前三位，第一位有九种选择，第二位有十种选择，第三位有十种选择。</p>
<p>我们发现，若一个 $cnt$ 位的回文串，我们需要构造出前 $(cnt+1)&#x2F; 2$ 位，共有 $9*10^{((cnt+1)&#x2F;2-1)}$ 种不同的回文串（第一位是 $9$ 种选择，其他位都是 $10$ 种选择）。这样我们就能知道第 $n$ 小的回文数是由几位数构成的了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_palindromes</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">char</span> s[])</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> cnt = <span class="number">1</span>, ans = <span class="number">9</span>;</span><br><span class="line">	<span class="keyword">while</span> (n &gt;= ans) &#123;</span><br><span class="line">		n -= ans;</span><br><span class="line">		cnt++;</span><br><span class="line">		ans = <span class="number">9</span> * <span class="built_in">pow</span>(<span class="number">10LL</span>, (cnt + <span class="number">1</span>) / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	n--;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = (cnt + <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		s[i] = n % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		n /= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s[<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = cnt; i &gt; (cnt + <span class="number">1</span>) / <span class="number">2</span>; i--) s[i] = s[cnt - i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s + <span class="number">1</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//注意传字符串s前，应先初始化s。</span></span><br></pre></td></tr></table></figure>

<h3 id="next回文数"><a href="#next回文数" class="headerlink" title="next回文数"></a>next回文数</h3><p>返回大于 $str$ 的最小回文数（即 $str$ 的下一个回文数），时间复杂度 $O(|str|)$ 。</p>
<p>对于一个形如 <strong>ABCDEFGH</strong>  的整数，<br>有且仅有一个比它大的最小回文数，<br>有且仅有一个比它小的最大回文数，<br>而整数 <strong>ABCDDCBA</strong> 一定是其中之一。</p>
<p>输入一个整数 <strong>ABCD</strong> ，若整数 <strong>ABBA</strong> 比 <strong>ABCD</strong> 大，则 <strong>ABBA</strong> 就是比它大的最小回文数，然后就可以直接输出这个答案了。</p>
<p>而如果 <strong>ABBA</strong> 比 <strong>ABCD</strong> 要小（或等于）那我们就要找到比 <strong>ABBA</strong> 大的下一个回文数。<br>不难发现它就是：<strong>ACCA</strong> 且 <strong>C&#x3D;B+1</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">get_next_palindromes</span><span class="params">(string&amp; str)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tt = str.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (tt &gt;= <span class="number">0</span> &amp;&amp; str[tt] == <span class="string">&#x27;9&#x27;</span>) str[tt] = <span class="string">&#x27;0&#x27;</span>, tt--;</span><br><span class="line">	<span class="keyword">if</span> (tt == <span class="number">-1</span>) str.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">&quot;0&quot;</span>), tt = <span class="number">0</span>;</span><br><span class="line">	str[tt] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	string s = str;</span><br><span class="line">	<span class="type">int</span> n = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span>; i++) s[i] = s[n - i] = str[i];</span><br><span class="line">	<span class="keyword">if</span> (s &gt;= str) <span class="keyword">return</span> s;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		tt = n / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (s[tt] == <span class="string">&#x27;9&#x27;</span>) s[tt] = s[n - tt] = <span class="string">&#x27;0&#x27;</span>, tt--;</span><br><span class="line">		s[tt] = s[n - tt] = s[tt] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>求 $a^k$ $%p$的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt=a;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=(res*cnt)%p;</span><br><span class="line">        cnt=(cnt*cnt)%p;</span><br><span class="line">        k=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>使用矩阵快速幂，我们只需要 $O(\log n)$ 的复杂度。</p>
<p>根据题目的递推关系 $(i&gt;&#x3D;3)$ :<br>$<br>f(i)&#x3D;f(i-1)+f(i-2)+f(i-3)<br>$</p>
<p>我们发现要求解 $f(i)$ ，其依赖的是 $f(i-1) 、 f(i-2)$ 和 $f(i-3)$ 。|</p>
<p>我们可以将其存成一个列向量：<br>$$<br>\left[\begin{array}{l}<br>f(i-1) \<br>f(i-2) \<br>f(i-3)<br>\end{array}\right]<br>$$</p>
<p>当我们整理出依赖的列向量之后，不难发现，我们想求的 $f(i)$ 所在的列向量是这样的:<br>$$<br>\left[\begin{array}{c}<br>f(i) \<br>f(i-1) \<br>f(i-2)<br>\end{array}\right]<br>$$</p>
<p>利用题目给定的依赖关系，对目标矩阵元素进行展开:<br>$$<br>\left[\begin{array}{c}<br>f(i) \<br>f(i-1) \<br>f(i-2)<br>\end{array}\right]&#x3D;\left[\begin{array}{l}<br>f(i-1) * 1+f(i-2) * 1+f(i-3) * 1 \<br>f(i-1) * 1+f(i-2) * 0+f(i-3) * 0 \<br>f(i-1) * 0+f(i-2) * 1+f(i-3) * 0<br>\end{array}\right]<br>$$</p>
<p>那么根据矩阵乘法，即有:<br>$$<br>\left[\begin{array}{c}<br>f(i) \<br>f(i-1) \<br>f(i-2)<br>\end{array}\right]&#x3D;\left[\begin{array}{lll}<br>1 &amp; 1 &amp; 1 \<br>1 &amp; 0 &amp; 0 \<br>0 &amp; 1 &amp; 0<br>\end{array}\right] *\left[\begin{array}{l}<br>f(i-1) \<br>f(i-2) \<br>f(i-3)<br>\end{array}\right]<br>$$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> mod=<span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Matrix</span>&#123;</span><br><span class="line">	<span class="type">int</span> a[maxn<span class="number">+3</span>][maxn<span class="number">+3</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">Matrix</span>()&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++) a[i][i]=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Matrix <span class="keyword">operator</span>*(Matrix&amp; b)&#123;</span><br><span class="line">		Matrix res;</span><br><span class="line">        <span class="built_in">memset</span>(res.a,<span class="number">0</span>,<span class="keyword">sizeof</span> res.a);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=maxn;j++)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=maxn;k++)&#123;</span><br><span class="line">					res.a[i][j]=(res.a[i][j]+a[i][k]*b.a[k][j])%mod;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Matrix <span class="keyword">operator</span>^(<span class="type">int</span> k)&#123;</span><br><span class="line">		Matrix res,cnt=*<span class="keyword">this</span>;</span><br><span class="line">		res.<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">while</span>(k)&#123;</span><br><span class="line">			<span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*cnt;</span><br><span class="line">			cnt=cnt*cnt;</span><br><span class="line">			k=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="求逆元"><a href="#求逆元" class="headerlink" title="求逆元"></a>求逆元</h2><p><strong>乘法逆元的定义</strong></p>
<p>定义一：若整数 $b$ ， $m$ 互质，并且对于任意的整数 $a$ ，如果满足 $b \mid a$ ，则存在一个整数 $x$ ，使得 $\frac{a}{b} \equiv a \times x(\bmod m)$ ，则称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为 $b^{-1}(\bmod m)$ 。<br>$b$ 存在乘法逆元的充要条件是 $b$ 与模数 $m$ 互质。当模数 $m$ 为质数时， $b^{m-2}$ 即为 $b$ 的乘法逆元。</p>
<p>定义二：如果一个线性同余方程 $a x \equiv 1(\bmod b)$ ，则 $x$ 称为 $a \bmod b$ 的逆元，记作 $a^{-1}$ 。</p>
<h3 id="1-p-是质数"><a href="#1-p-是质数" class="headerlink" title="1. $p$是质数"></a>1. $p$是质数</h3><p>若 $a$ 不是 $p$ 的倍数，则 $a$ 的乘法逆元为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">qmi</span>(a,p<span class="number">-2</span>,p);</span><br></pre></td></tr></table></figure>

<p>若 $a$ 是 $p$ 的倍数，则 $a$ 没有乘法逆元</p>
<h3 id="2-p-不是质数"><a href="#2-p-不是质数" class="headerlink" title="2. $p$不是质数"></a>2. $p$不是质数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, p, x, y;</span><br><span class="line">        <span class="comment">// if (a &lt; p) swap(a, p);</span></span><br><span class="line">        cin &gt;&gt;  a &gt;&gt; p;</span><br><span class="line">        <span class="type">int</span> d = <span class="built_in">exgcd</span>(a, p, x, y);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">1</span>) cout &lt;&lt; ((LL)x + p) % p &lt;&lt; endl;<span class="comment">//保证x是正数</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相等式"><a href="#相等式" class="headerlink" title="相等式"></a>相等式</h2><p>$x<em>a+y</em>b$ </p>
<p>$a^x+y*b$</p>
<p>其中a,b为常正整数，x，y定义域均为0到正无穷，值域<strong>似乎</strong>相等</p>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><p>$C_n^m$<br>$$<br>\begin{gathered}<br>\binom{n}{m}&#x3D;\binom{n-1}{m}+\binom{n-1}{m-1} \\<br>\binom{n}{m}&#x3D;\frac{n!}{m!(n-m)!} \\<br>\binom{n}{m}&#x3D;\binom{n % p}{m % p} *\binom{\lfloor n &#x2F; p\rfloor}{\lfloor m &#x2F; p\rfloor}(p \text { 是质数 })<br>\end{gathered}<br>$$</p>
<h3 id="预处理组合数-组合递推式"><a href="#预处理组合数-组合递推式" class="headerlink" title="预处理组合数+组合递推式"></a>预处理组合数+组合递推式</h3><p>时间复杂度 $O(n^2)$</p>
<p>$C_n^m &#x3D; f[n][m]$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">2100</span>][<span class="number">2100</span>];</span><br><span class="line"><span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">asd1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2000</span>;i++)&#123;</span><br><span class="line">        f[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            f[i][j]=(f[i<span class="number">-1</span>][j]+f[i<span class="number">-1</span>][j<span class="number">-1</span>])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n][m];</span><br></pre></td></tr></table></figure>

<h3 id="预处理阶乘-逆元"><a href="#预处理阶乘-逆元" class="headerlink" title="预处理阶乘+逆元"></a>预处理阶乘+逆元</h3><p>时间复杂度 $O(n\log(mod))$</p>
<p>$C_n^m &#x3D; f[n]\ <em>\ inf[m]\ </em>\ inf[n-m]$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> f[<span class="number">100010</span>],inf[<span class="number">100010</span>],mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt=a;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*cnt%p;</span><br><span class="line">        cnt=cnt*cnt%p;</span><br><span class="line">        k=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    inf[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=(f[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) inf[i]=(inf[i<span class="number">-1</span>]*<span class="built_in">qmi</span>(i,mod<span class="number">-2</span>,mod))%mod;</span><br><span class="line">    <span class="comment">// 或者 inf[i]=qmi(f[i],mod-2,mod);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((f[n]*inf[m])%mod*inf[n-m])%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 $(n−1)!^{−1}≡n!^{−1}*n % mod$ ，所以可以用逆序优化，时间复杂度 $O(max(n,log\ mod))$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> f[N],inf[N],mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> k,<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> cnt=a;</span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;<span class="number">1</span>) res=res*cnt%p;</span><br><span class="line">        cnt=cnt*cnt%p;</span><br><span class="line">        k=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=(f[i<span class="number">-1</span>]*i)%mod;</span><br><span class="line">    inf[n]=<span class="built_in">qmi</span>(f[n],mod<span class="number">-2</span>,mod);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) inf[i]=(inf[i<span class="number">+1</span>]*(i<span class="number">+1</span>))%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((f[n]*inf[m])%mod*inf[n-m])%mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Lucas"><a href="#Lucas" class="headerlink" title="Lucas"></a>Lucas</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = (LL)res * a % p;</span><br><span class="line">        a = (LL)a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = a; i &lt;= b; i ++, j -- )</span><br><span class="line">    &#123;</span><br><span class="line">        res = (LL)res * j % p;</span><br><span class="line">        res = (LL)res * <span class="built_in">qmi</span>(i, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lucas</span><span class="params">(LL a, LL b, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; p &amp;&amp; b &lt; p) <span class="keyword">return</span> <span class="built_in">C</span>(a, b, p);</span><br><span class="line">    <span class="keyword">return</span> (LL)<span class="built_in">C</span>(a % p, b % p, p) * <span class="built_in">lucas</span>(a / p, b / p, p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三角形面积"><a href="#三角形面积" class="headerlink" title="三角形面积"></a>三角形面积</h2><img data-src="https://wuli.wiki/online/16ffe3e6e8442404.svg"/>

<h3 id="海伦公式"><a href="#海伦公式" class="headerlink" title="海伦公式"></a>海伦公式</h3><p>若已知三角形的边长（图 1），其面积可以用海伦公式计算<br>$$<br>A&#x3D;\sqrt{s(s-a)(s-b)(s-c)}<br>$$</p>
<p>其中 $s&#x3D;(a+b+c) &#x2F; 2$ 。</p>
<h3 id="秦九韶公式"><a href="#秦九韶公式" class="headerlink" title="秦九韶公式"></a>秦九韶公式</h3><p>是与海伦公式等价的一个公式<br>$$<br>A&#x3D;\frac{1}{2} \sqrt{a^2 b^2-\left(\frac{a^2+b^2-c^2}{2}\right)^2}<br>$$</p>
<h3 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h3><p>$$<br>S&#x3D;\frac{1}{2}absinθ<br>$$</p>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="公平组合游戏"><a href="#公平组合游戏" class="headerlink" title="公平组合游戏"></a>公平组合游戏</h3><p><a href="https://heartlessly.github.io/notes/qian-xi-sg-han-shu-yu-sg-ding-li/">浅析SG函数与SG定理 | Heartlessly’s Blog</a></p>
]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2024/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>数据结构</p>
<span id="more"></span>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>查询 $str(|str|&#x3D;m)$ 在 $s(|s|&#x3D;n)$ 中所有出现的位置的起始下标。</p>
<p>$find()$ 的时间复杂度为 $O(n*m)$;</p>
<p>$kmp$ 的时间复杂度为 $O(n+m)$;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    s--,str--;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ne[len<span class="number">+10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; str[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (str[i] == str[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == str[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == len) &#123;</span><br><span class="line">            cout &lt;&lt; i - len &lt;&lt; <span class="string">&quot; &quot;</span>;      <span class="comment">//return;</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(string s, string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ne[m + <span class="number">10</span>];</span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; str[j + <span class="number">1</span>] != str[i]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (str[j + <span class="number">1</span>] == str[i]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == str[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i - j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p><img data-src="/../images/trie1.png" alt="trie1"></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h3><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>时间复杂度 $O\left(m \log _{1+\frac{m}{n}} n\right)$（ $m$ 为操作数 ），近似 $O(1)$ 。<a href="https://www.luogu.com/article/x3u368oh">时间复杂度-势能分析浅谈 </a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">	<span class="built_in">DSU</span>(<span class="type">int</span> n):<span class="built_in">p</span>(n)&#123;</span><br><span class="line">		<span class="built_in">iota</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x!=p[x]) <span class="keyword">return</span> p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">		<span class="keyword">return</span> p[x];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		p[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="启发式合并-路径压缩"><a href="#启发式合并-路径压缩" class="headerlink" title="启发式合并+路径压缩"></a>启发式合并+路径压缩</h4><p>时间复杂度 $O(m\alpha (n))$ ，$\alpha (n)$ 近似看成常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; p,size;</span><br><span class="line">	<span class="built_in">DSU</span>(<span class="type">int</span> n):<span class="built_in">p</span>(n),<span class="built_in">size</span>(n,<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">iota</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x!=p[x]) <span class="keyword">return</span> p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">		<span class="keyword">return</span> p[x];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		x=<span class="built_in">find</span>(x),y=<span class="built_in">find</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> ;</span><br><span class="line">		<span class="keyword">if</span>(size[x]&gt;size[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">		p[x]=y,size[y]+=size[x];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h3><p><a href="https://www.luogu.com.cn/problem/P2024">食物链 - 洛谷 </a></p>
<p>对于 $i∈[1,n]$ ，我们用 $i+n$ 表示 $i$ 的天敌，用 $i+2n$ 表示它的食物，合并的时候按照关系合并同类型的动物就可以了。</p>
<p>比如：对于动物 $x$ 和它的天敌 $y$ ，我们可以 ：</p>
<p>$merge(x+n,y),merge(x+2∗n,y+n),merge(x,y+2∗n)$</p>
<p>表示合并 $x$ 的天敌和 $y$ ，合并 $x$ 的食物和 $y$ 的天敌，合并 $x$ 和 $y$ 的食物。</p>
<p>对于同类动物 $x$ 和 $y$ ，我们可以：</p>
<p>$merge(x,y),merge(x+n,y+n),merge(x+2∗n,y+2∗n)$</p>
<p>这样对某个元素 $x$ ，如果有 $same(x,x+n)&#x3D;&#x3D;true||same(x,x+2∗n)&#x3D;&#x3D;true$ 那么一定有命题是错误的。</p>
<h3 id="加权并查集"><a href="#加权并查集" class="headerlink" title="加权并查集"></a>加权并查集</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span>&#123;</span><br><span class="line">	<span class="type">int</span> m;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; p,v;</span><br><span class="line">	<span class="comment">//n：大小，m：最大坐标+1（种类数）</span></span><br><span class="line">	<span class="comment">//v[i]：i据父节点距离，使用时需先same或find，将i的祖宗节点变为父节点，这时v[i]代表其坐标。</span></span><br><span class="line">	<span class="built_in">DSU</span>(<span class="type">int</span> n,<span class="type">int</span> m):<span class="built_in">m</span>(m),<span class="built_in">p</span>(n),<span class="built_in">v</span>(n,<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">iota</span>(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">			<span class="type">int</span> px=p[x];</span><br><span class="line">			p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">			v[x]=(v[x]+v[px])%m;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> p[x];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> dis)</span></span>&#123;</span><br><span class="line">		<span class="type">int</span> fx=<span class="built_in">find</span>(x),fy=<span class="built_in">find</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(fx!=fy)&#123;</span><br><span class="line">			v[fx]=(dis+v[y]-v[x]+m)%m;</span><br><span class="line">			p[fx]=fy;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">fc</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">		<span class="built_in">find</span>(x);</span><br><span class="line">		<span class="keyword">return</span> v[x];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取x，y的距离</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">fc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">fc</span>(x)-<span class="built_in">fc</span>(y)+m)%m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="built_in">dsu</span>(N,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><span style='color:red;background:背景颜色;font-size:文字大小;font-family:宋体;'>开long long</span></p>
<p><strong>区间修改 + 单点查询</strong> 用差分可以改为 <strong>单点修改 + 区间查询</strong></p>
<p>用差分时注意数组越界问题</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等</p>
<h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,sum,lz;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	tree[u].sum=tree[u&lt;&lt;<span class="number">1</span>].sum+tree[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(node&amp; f,node&amp; ls,node&amp; rs)</span></span>&#123;</span><br><span class="line">	ls.sum+=(ls.r-ls.l<span class="number">+1</span>)*f.lz;</span><br><span class="line">	rs.sum+=(rs.r-rs.l<span class="number">+1</span>)*f.lz;</span><br><span class="line">	ls.lz+=f.lz; rs.lz+=f.lz; f.lz=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="built_in">pushdown</span>(tree[u],tree[u&lt;&lt;<span class="number">1</span>],tree[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tree[u]=node&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tree[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r)&#123;</span><br><span class="line">		tree[u].lz+=k;</span><br><span class="line">		tree[u].sum+=(tree[u].r-tree[u].l<span class="number">+1</span>)*k;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r) <span class="keyword">return</span> tree[u].sum;</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加法乘法混合"><a href="#加法乘法混合" class="headerlink" title="加法乘法混合"></a>加法乘法混合</h3><p>转化成先乘再加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,sum,add,mul;</span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> n,mod,q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	tree[u].sum=tree[u&lt;&lt;<span class="number">1</span>].sum+tree[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">	tree[u].sum%=mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(node&amp; f,node&amp; ls,node&amp; rs)</span></span>&#123;</span><br><span class="line">	ls.sum=(ls.sum*f.mul+(ls.r-ls.l<span class="number">+1</span>)*f.add)%mod;</span><br><span class="line">	rs.sum=(rs.sum*f.mul+(rs.r-rs.l<span class="number">+1</span>)*f.add)%mod;</span><br><span class="line">	ls.mul=(ls.mul*f.mul)%mod;</span><br><span class="line">	rs.mul=(rs.mul*f.mul)%mod;</span><br><span class="line">	ls.add=(ls.add*f.mul+f.add)%mod;</span><br><span class="line">	rs.add=(rs.add*f.mul+f.add)%mod;</span><br><span class="line">	f.add=<span class="number">0</span>;</span><br><span class="line">	f.mul=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="built_in">pushdown</span>(tree[u],tree[u&lt;&lt;<span class="number">1</span>],tree[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	tree[u]=node&#123;l,r,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		tree[u].sum=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r)&#123;</span><br><span class="line">		tree[u].add+=k;</span><br><span class="line">		tree[u].add%=mod;</span><br><span class="line">		tree[u].sum+=(tree[u].r-tree[u].l<span class="number">+1</span>)*k;</span><br><span class="line">		tree[u].sum%=mod;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">add</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r)&#123;</span><br><span class="line">		tree[u].mul*=k;</span><br><span class="line">		tree[u].add*=k;</span><br><span class="line">		tree[u].sum*=k;</span><br><span class="line">		tree[u].mul%=mod;</span><br><span class="line">		tree[u].add%=mod;</span><br><span class="line">		tree[u].sum%=mod;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) <span class="built_in">mul</span>(u&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) <span class="built_in">mul</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r,k);</span><br><span class="line">	<span class="built_in">pushup</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r) <span class="keyword">return</span> tree[u].sum;</span><br><span class="line">	<span class="built_in">pushdown</span>(u);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>,mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid) ans+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid) ans+=<span class="built_in">query</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q&gt;&gt;mod;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="comment">//for(int i=1;i&lt;=10;i++) cout&lt;&lt;tree[i].l&lt;&lt;&quot; &quot;&lt;&lt;tree[i].r&lt;&lt;&quot; &quot;&lt;&lt;tree[i].sum&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">		<span class="type">int</span> op,x,y,k;</span><br><span class="line">		cin&gt;&gt;op;</span><br><span class="line">		<span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">mul</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>)&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">			<span class="built_in">add</span>(<span class="number">1</span>,x,y,k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">			cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">越界  n+10</span><br><span class="line">区间修改，查询操作前先 pushdown</span><br><span class="line">修改之后 pushup</span><br><span class="line">pushdown函数记得把父节点的懒标记清空</span><br></pre></td></tr></table></figure>

<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>树状数组思想<br>树状数组的本质思想是使用树结构维护”前缀和”，从而把时间复杂度降为 $O(logn)$ 。</p>
<p>对于一个序列，对其建立如下树形结构：</p>
<ol>
<li><p>每个结点 $t[x]$ 保存以 $x$ 为根的子树中叶结点值的和</p>
</li>
<li><p>每个结点覆盖的长度为 $lowbit(x)$</p>
</li>
<li><p>$t[x]$ 结点的父结点为 $t[x + lowbit(x)]$</p>
</li>
<li><p>树的深度为 $log_2n+1$</p>
</li>
</ol>
<p>修改：将 $u$ 的所有祖宗节点加 $x$ 。</p>
<p>查询：$[l,r]$ 的区间和是 $ask(r) - ask(l-1)$ 。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>下标不能从 $0$ 开始。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">	<span class="type">int</span> n;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">tree</span>(<span class="type">int</span> n) : <span class="built_in">n</span>(n), <span class="built_in">t</span>(n + <span class="number">10</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i = i + <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">			t[i] += k;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = x; i; i = i - <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">			ans += t[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">ask</span>(r) - <span class="built_in">ask</span>(l - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">tree <span class="title">tr</span><span class="params">(n)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-单点修改-区间查询"><a href="#1-单点修改-区间查询" class="headerlink" title="1. 单点修改 + 区间查询"></a>1. 单点修改 + 区间查询</h3><p>前缀和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=n;i=i+<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		t[i]+=k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=x;i;i=i-<span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">		ans+=t[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x位置加k</span></span><br><span class="line"><span class="built_in">add</span>(x,k);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;(<span class="built_in">ask</span>(r)-<span class="built_in">ask</span>(l<span class="number">-1</span>))&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-区间修改-单点查询"><a href="#2-区间修改-单点查询" class="headerlink" title="2. 区间修改 + 单点查询"></a>2. 区间修改 + 单点查询</h3><p>差分</p>
<p>树状数组函数和上者一样，不同的是使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区间[x,y]加 k</span></span><br><span class="line"><span class="built_in">add</span>(x,k);</span><br><span class="line"><span class="built_in">add</span>(y<span class="number">+1</span>,-k);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 询问a[x]</span></span><br><span class="line">cout&lt;&lt;<span class="built_in">ask</span>(x)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-区间修改-区间查询"><a href="#3-区间修改-区间查询" class="headerlink" title="3. 区间修改 + 区间查询"></a>3. 区间修改 + 区间查询</h3><p>这是最常用的部分，也是用线段树写着最麻烦的部分——但是现在我们有了树状数组!<br>怎么求呢? 我们基于问题2的”差分”思路，考虑一下如何在问题2构建的树状数组中求前缀和:<br>位置 $p$ 的前缀和 $&#x3D;$<br>$$<br>\sum_{i&#x3D;1}^p a[i]&#x3D;\sum_{i&#x3D;1}^p \sum_{j&#x3D;1}^i d[j]<br>$$</p>
<p>在等式最右侧的式子 $\sum_{i&#x3D;1}^p \sum_{j&#x3D;1}^i d[j]$ 中， $d[1]$ 被用了 $p$ 次， $d[2]$ 被用了 $p-1$ 次…..那么我们可以写出:<br>位置p的前缀和 $&#x3D;$<br>$$<br>\sum_{i&#x3D;1}^p \sum_{j&#x3D;1}^i d[j]&#x3D;\sum_{i&#x3D;1}^p d[i] *(p-i+1)&#x3D;(p+1) * \sum_{i&#x3D;1}^p d[i]-\sum_{i&#x3D;1}^p d[i] * i<br>$$</p>
<p>那么我们可以维护两个数组的前缀和:</p>
<p>一个数组是 $\operatorname{sum} 1[i]&#x3D;d[i]$ ，</p>
<p>另一个数组是 $\operatorname{sum} 2[i]&#x3D;d[i] * i$ 。<br><strong>查询</strong><br>位置p的前缀和即： $(p+1) * sum1$ 数组中 $p$ 的前缀和 - sum2数组中 $p$ 的前缀和。</p>
<p>区间 $[l, r]$ 的和即：位置 $r$ 的前缀和 $-$ 位置 $l$ 的前缀和。<br><strong>修改</strong></p>
<p>对于 $sum1$ 数组的修改同问题 2 中对 d 数组的修改。</p>
<p>对于 $sum2$ 数组的修改也类似，我们给 $sum2[l]$ 加上 $l * x$ ，给 $sum2[r+1]$ 减去 $(r+1) * x$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-二维树状数组"><a href="#4-二维树状数组" class="headerlink" title="4. 二维树状数组"></a>4. 二维树状数组</h3><h2 id="st表"><a href="#st表" class="headerlink" title="st表"></a>st表</h2><p>ST表（Sparse Table，稀疏表）是一种简单的数据结构，主要用来解决RMQ（Range Maximum&#x2F;Minimum Query，区间最大&#x2F;最小值查询）问题。它主要应用倍增的思想，可以实现 $O(nlogn)$ 预处理、$O(1)$ 查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1e6</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; ++i)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + (<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span> &lt;= n; ++j)</span><br><span class="line">        f[j][i] = <span class="built_in">max</span>(f[j][i - <span class="number">1</span>], f[j + (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))][i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="type">int</span> s = __lg(r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[l][s], f[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$log2()$ 函数手写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    Log2[i] = Log2[i / <span class="number">2</span>] + <span class="number">1</span>;	</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>杂项</title>
    <url>/2024/11/25/%E6%9D%82%E9%A1%B9/</url>
    <content><![CDATA[<p>杂项</p>
<span id="more"></span>

<h2 id="O2、O3优化"><a href="#O2、O3优化" class="headerlink" title="O2、O3优化"></a>O2、O3优化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3,<span class="string">&quot;Ofast&quot;</span>,<span class="string">&quot;inline&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择:</p>
<ol>
<li>$n \leq 30$, 指数级别, dfs+剪枝，状态压缩dp</li>
<li>$n \leq 100&#x3D;&gt;\left(n^3\right)$ ， floyd， dp ，高斯消元</li>
<li>$n \leq 1000&#x3D;&gt;\left(n^2\right) ， O\left(n^2 \log n\right)$ ，dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford</li>
<li>$n \leq 10000&#x3D;&gt;O(n * \sqrt{n})$ ，块状链表、分块、莫队</li>
<li>$n \leq 100000&#x3D;&gt;(n \log n)&#x3D;&gt;$ 各种sort，线段树、树状数组、set&#x2F;map、heap、拓扑排序、dijkstra+heap、 prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树</li>
<li>$n \leq 1000000&#x3D;&gt;O(n)$, 以及常数较小的 $O(n \log n)$ 算法 &#x3D;&gt; 单调队列、hash、双指针扫描、BFS、并查集， kmp、AC自动机，常数比较小的 $O(n \operatorname{logn})$ 的做法: sort、树状数组、heap、dijkstra、spfa</li>
<li>$n \leq 10000000&#x3D;&gt;O(n)$ ，双指针扫描、kmp、AC自动机、线性䇛素数</li>
<li>$n \leq 10^9&#x3D;&gt;(\sqrt{n})$ ，判断质数</li>
<li>$n \leq 10^{18}&#x3D;&gt;(\operatorname{logn})$ ，最大公约数，快速幂，数位 DP</li>
<li>$n \leq 10^{1000}&#x3D;&gt;\left((\log n)^2\right)$ ，高精度加减乘除</li>
<li>$n \leq 10^{100000}&#x3D;&gt;(\log k \times \log \log k), k$ 表示位数，高精度加减、FFT&#x2F;NTT</li>
<li>暴力</li>
</ol>
<h2 id="对拍"><a href="#对拍" class="headerlink" title="对拍"></a>对拍</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rand</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">r</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="function">mt19937_64 <span class="title">rng</span><span class="params">(chrono::steady_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">rng</span>()%(r-l<span class="number">+1</span>)+l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//T=rng()%10000+1;</span></span><br><span class="line">	<span class="comment">//cout&lt;&lt;T&lt;&lt;&quot;\n&quot;;</span></span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compare</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">system</span>(<span class="string">&quot;rand.exe &gt; date.in&quot;</span>);</span><br><span class="line">	    <span class="built_in">system</span>(<span class="string">&quot;test1.exe &lt; date.in &gt; 1.out&quot;</span>);</span><br><span class="line">	    <span class="built_in">system</span>(<span class="string">&quot;test2.exe &lt;date.in &gt; 2.out&quot;</span>);</span><br><span class="line">	    <span class="keyword">if</span>(<span class="built_in">system</span>(<span class="string">&quot;fc  1.out 2.out&quot;</span>))&#123;</span><br><span class="line">			<span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">	    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>查询 $str(|str|&#x3D;m)$ 在 $s(|s|&#x3D;n)$ 中所有出现的位置的起始下标。</p>
<p>$find()$ 的时间复杂度为 $O(n*m)$;</p>
<p>$kmp$ 的时间复杂度为 $O(n+m)$;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(<span class="type">char</span> *s,<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    s--,str--;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ne[len<span class="number">+10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; str[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (str[i] == str[j + <span class="number">1</span>]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == str[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == len) &#123;</span><br><span class="line">            cout &lt;&lt; i - len &lt;&lt; <span class="string">&quot; &quot;</span>;      <span class="comment">//return;</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">(string s, string str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> ne[m + <span class="number">10</span>];</span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">-1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; str[j + <span class="number">1</span>] != str[i]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (str[j + <span class="number">1</span>] == str[i]) j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">-1</span> &amp;&amp; s[i] != str[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == str[j + <span class="number">1</span>]) j++;</span><br><span class="line">        <span class="keyword">if</span> (j == m - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i - j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            j = ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p><span style='color:red;background:背景颜色;font-size:文字大小;font-family:字体;'>开 long long</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较A，B大小</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()==B.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]!=B[i]) <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大-小</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t=t+A[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t=t-B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t<span class="number">+10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(max(A.size(),B.size())<span class="number">+10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++) C[i]+=A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;B.<span class="built_in">size</span>();i++) C[i]+=B[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;C.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        C[i<span class="number">+1</span>]+=C[i]/<span class="number">10</span>;</span><br><span class="line">        C[i]=C[i]%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">      t=t+A[i]*b;</span><br><span class="line">      C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">      t=t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t=t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mull</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, vector&lt;<span class="type">int</span>&gt;&amp; B)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">C</span><span class="params">(A.size()+B.size()<span class="number">+10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;B.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            C[i+j]+=A[i]*B[j];                  <span class="comment">//+=</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i<span class="number">+1</span>&lt;C.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        C[i<span class="number">+1</span>]+=C[i]/<span class="number">10</span>;                        <span class="comment">//+=</span></span><br><span class="line">        C[i]=C[i]%<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// r是余数</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A, <span class="type">int</span> b, <span class="type">int</span>&amp; r)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C; r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        r=r*<span class="number">10</span>+A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r=r%b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C=<span class="built_in">mull</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) cout&lt;&lt;C[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> P=<span class="number">131</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> h[<span class="number">100010</span>],p[<span class="number">100010</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;s<span class="number">+1</span>;</span><br><span class="line">p[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;s[i];i++)&#123;</span><br><span class="line">    h[i]=h[i<span class="number">-1</span>]*P+s[i];</span><br><span class="line">    p[i]=p[i<span class="number">-1</span>]*P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><h2 id="字符串与数字转化"><a href="#字符串与数字转化" class="headerlink" title="字符串与数字转化"></a>字符串与数字转化</h2><h3 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">string = <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">stoi</span>(str); <span class="comment">//转换为整型 n = 123456（转换失败时发生异常）</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">atoi</span>(str); <span class="comment">//转换为整型 n = 123456（转换失败时返回0）</span></span><br><span class="line">string = <span class="string">&quot;123456.123&quot;</span></span><br><span class="line"><span class="type">double</span> d = <span class="built_in">stof</span>(str); <span class="comment">//转换为浮点数 d = 123456.123（转换失败时发生异常）</span></span><br><span class="line"><span class="type">double</span> d = <span class="built_in">atof</span>(str); <span class="comment">//转换为浮点数 d = 123456.123（转换失败时返回0）</span></span><br></pre></td></tr></table></figure>

<h3 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">//需要引入string头文件</span></span></span><br><span class="line"><span class="type">int</span> num = <span class="number">123456</span></span><br><span class="line">string str = <span class="built_in">to_string</span>(num); <span class="comment">//转换为字符串 str = &quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="位运算技巧"><a href="#位运算技巧" class="headerlink" title="位运算技巧"></a>位运算技巧</h2><p><a href="https://leetcode.cn/circle/discuss/CaOJ45/">分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x &amp; (x - <span class="number">1</span>)       <span class="comment">// 消除二进制下最后出现1的位置，其余保持不变</span></span><br><span class="line">x &amp; -x            <span class="comment">// 获得x最后一个 1 的位置   1110-&gt;10   1111-&gt;1 </span></span><br><span class="line">x &amp; -x == x       <span class="comment">// x是2的整次幂</span></span><br><span class="line">__builtin_popcount(s)   <span class="comment">// 计算s中1的个数（int）</span></span><br><span class="line">__builtin_popcountll(s) <span class="comment">// 计算s中1的个数（long long）</span></span><br><span class="line">__lg(s)<span class="number">+1</span>               <span class="comment">// 计算s的长度</span></span><br></pre></td></tr></table></figure>

<h2 id="logtrick"><a href="#logtrick" class="headerlink" title="logtrick"></a>logtrick</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">closestToTarget</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=arr.<span class="built_in">size</span>(),mi=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        mi=<span class="built_in">min</span>(mi,<span class="built_in">abs</span>(target-arr[i]));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]==(arr[j]&amp;arr[i])) <span class="keyword">break</span>;</span><br><span class="line">            arr[j]&amp;=arr[i];</span><br><span class="line">            mi=<span class="built_in">min</span>(mi,<span class="built_in">abs</span>(target-arr[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">clock_t</span> end = <span class="built_in">clock</span>();</span><br><span class="line"><span class="type">double</span> time=<span class="built_in">double</span>(end-start)/CLOCKS_PER_SEC;</span><br></pre></td></tr></table></figure>

<h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n个人，下标从1开始，每次报到 k 淘汰</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		s = (s + k) % i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/2024/11/25/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/oneway10101/p/17642080.html#%E6%B1%82%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AFpolygon_area">计算几何基本模板（二维）</a></p>
<span id="more"></span>

<p><strong>直线方向向量</strong></p>
<p>对 $Ax+By+C&#x3D;0$ , 法向量 $(A, B)$ , 方向向量 $(-B, A)$ 。</p>
<p>设一般方程: $A x+B y+C&#x3D;0$<br>写成斜截式： $y&#x3D;-\frac{A}{B} x-\frac{C}{B}$<br>那么它的斜率 $k&#x3D;-\frac{A}{B}$<br>过原点做一条平行线 $y&#x3D;-\frac{A}{B} x$<br>取 $x&#x3D;B$ ，得到 $y&#x3D;-A$.那么得到一个方向向量即 $\alpha&#x3D;(B,-A)$ 。</p>
<p><strong>两直线交点</strong></p>
<p>直线 $l_1$ 的一般式为：$$ A_1x + B_1y + C_1 &#x3D; 0 $$<br>直线 $l_2$ 的一般式为：$$ A_2x + B_2y + C_2 &#x3D; 0 $$</p>
<p>两条直线 $l_1$ 和 $l_2$ 的交点是：<br>$$<br>\left( \frac{B_1C_2 - B_2C_1}{A_1B_2 - A_2B_1}, \frac{A_1C_2 - A_2C_1}{A_2B_1 - A_1B_2} \right)<br>$$</p>
<p>注意：如果 $A_2B_1 - A_1B_2 &#x3D; 0$，则方程组无解（平行且不重合）或有无穷多解（重合）。</p>
<p><strong>直线一般式</strong></p>
<p>$fs(x)$ 防止输出 $-0.00$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fs(x) (abs(x) &lt; eps) ? 0 : (x)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> x, y;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> node&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x == b.x &amp;&amp; y == b.y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> a, b, c;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Line&amp; l)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a == l.a ? (b == l.b ? c &lt; l.c : b &lt; l.b) : (a &lt; l.a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Line&amp; l)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a == l.a &amp;&amp; b == l.b &amp;&amp; c == l.c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直线是否过点A</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">through</span><span class="params">(node A)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a * A.x + b * A.y + c == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l1,l2是否相交</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersect</span><span class="params">(Line l1, Line l2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !(l<span class="number">1.</span>a * l<span class="number">2.</span>b == l<span class="number">1.</span>b * l<span class="number">2.</span>a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l1,l2交点</span></span><br><span class="line"><span class="function">Point <span class="title">intersection</span><span class="params">(Line l1, Line l2)</span> </span>&#123;</span><br><span class="line">	<span class="type">double</span> A1 = l<span class="number">1.</span>a, B1 = l<span class="number">1.</span>b, C1 = l<span class="number">1.</span>c, A2 = l<span class="number">2.</span>a, B2 = l<span class="number">2.</span>b, C2 = l<span class="number">2.</span>c;</span><br><span class="line">	<span class="keyword">return</span> &#123; (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1),(A1 * C2 - A2 * C1) / (A2 * B1 - A1 * B2) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// x1,x2不能相等</span></span><br><span class="line"><span class="function">Line <span class="title">make_line</span><span class="params">(node x1, node x2)</span> </span>&#123;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> a = x<span class="number">1.</span>y - x<span class="number">2.</span>y;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> b = x<span class="number">2.</span>x - x<span class="number">1.</span>x;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> c = x<span class="number">1.</span>x * x<span class="number">2.</span>y - x<span class="number">1.</span>y * x<span class="number">2.</span>x;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> g = <span class="built_in">gcd</span>(a, <span class="built_in">gcd</span>(b, c));</span><br><span class="line">	a /= g, b /= g, c /= g;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		a = -a, b = -b, c = -c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Line&#123; a,b,c &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>凸包</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> Pi = <span class="number">3.141592653589793</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x != b.x ? x &lt; b.x : y &lt; b.y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Point <span class="keyword">operator</span>+(<span class="type">const</span> Point&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123; x + b.x,y + b.y &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量</span></span><br><span class="line">	Point <span class="keyword">operator</span>-(<span class="type">const</span> Point&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123; x - b.x,y - b.y &#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点积</span></span><br><span class="line">	<span class="type">double</span> <span class="keyword">operator</span>*(<span class="type">const</span> Point&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * b.x + y * b.y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叉积</span></span><br><span class="line">	<span class="type">double</span> <span class="keyword">operator</span>^(<span class="type">const</span> Point&amp; b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x * b.y - y * b.x;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两点距离</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(Point b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">hypot</span>(x - b.x, y - b.y);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绕p逆时针转angle弧度</span></span><br><span class="line">	<span class="function">Point <span class="title">rotate</span><span class="params">(Point p, <span class="type">double</span> angle)</span> </span>&#123;</span><br><span class="line">		Point v = (*<span class="keyword">this</span>) - p;</span><br><span class="line">		<span class="type">double</span> c = <span class="built_in">cos</span>(angle), s = <span class="built_in">sin</span>(angle);</span><br><span class="line">		<span class="keyword">return</span> &#123; p.x + v.x * c - v.y * s,p.y + v.y * c + v.x * s &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_right</span><span class="params">(Point a, Point b, Point c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((c - a) ^ (b - a)) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(p + <span class="number">1</span>, p + <span class="number">1</span> + size);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">	<span class="keyword">while</span> (tt &gt;= <span class="number">2</span> &amp;&amp; <span class="built_in">is_right</span>(stk[tt - <span class="number">1</span>], stk[tt], p[i])) tt--;</span><br><span class="line">	stk[++tt] = p[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = tt;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = size; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">	<span class="keyword">while</span> (tt &gt;= len + <span class="number">1</span> &amp;&amp; <span class="built_in">is_right</span>(stk[tt - <span class="number">1</span>], stk[tt], p[i])) tt--;</span><br><span class="line">	stk[++tt] = p[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
</search>
