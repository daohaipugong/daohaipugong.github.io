<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/11/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>杂项</category>
      </categories>
  </entry>
  <entry>
    <title>字符串 &amp;&amp; 输入输出</title>
    <url>/2024/11/25/c++%E6%9D%BF%E5%AD%90/%E5%AD%97%E7%AC%A6%E4%B8%B2%20&amp;&amp;%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>字符串</p>
<span id="more"></span>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h3><p><code>scanf</code> 读字符时会读入空格、换行</p>
<p><code>scanf</code> 读字符串时不会读入空格、换行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> c,cc;<br><span class="hljs-type">int</span> x;<br>cin&gt;&gt;x&gt;&gt;c&gt;&gt;cc;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%c%c&quot;</span>,&amp;x,&amp;c,&amp;cc);<br>cout&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;cc;<br></code></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><p><code>cin</code> 不会读入开始的换行、空格，遇到空格、换行停止</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//char s[1000];</span><br><span class="hljs-comment">//char s;</span><br>string s;<br>cin&gt;&gt;s;<br></code></pre></td></tr></table></figure>

<h3 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h3><p><code>getchar</code> 会读入换行和空格，但是不能与IOS同时使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br></code></pre></td></tr></table></figure>

<h3 id="ignore"><a href="#ignore" class="headerlink" title="ignore()"></a>ignore()</h3><p>从输入流中移除（忽略）下一个字符</p>
<p>如果计数值达到 $a$ 或者被抛弃的字符是 $ch$ ，则 <code>cin.ignore()</code> 函数执行终止；否则，它继续等待。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">cin.<span class="hljs-built_in">ignore</span>();<br>cin.<span class="hljs-built_in">ignore</span>(a,ch)<br></code></pre></td></tr></table></figure>

<h3 id="getline"><a href="#getline" class="headerlink" title="getline()"></a>getline()</h3><p>读入一行字符串，遇到换行停止。使用前一般先清除缓存区换行符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-built_in">getline</span>(cin,s);<br></code></pre></td></tr></table></figure>

<p><strong>清除缓存区换行方法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">cin.<span class="hljs-built_in">ignore</span>();<br><span class="hljs-built_in">getchar</span>();      <span class="hljs-comment">//不能与IOS同时使用。</span><br><span class="hljs-built_in">getline</span>(cin,s);<br></code></pre></td></tr></table></figure>

<h3 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h3><p><code>stringstream</code> 可以逐个读取单词（或更准确地说，是由空白字符分隔的字符串序列）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">string s;<br><span class="hljs-built_in">getline</span>(cin,s);<br><span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(s)</span></span>;   <span class="hljs-comment">//将ss初始化为s</span><br>string str;<br><span class="hljs-keyword">while</span>(ss&gt;&gt;str)&#123;       <span class="hljs-comment">//逐个读取单词，读取到str中</span><br>    cout&lt;&lt;str&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs cppp">八进制: %o<br>十六进制: %x<br></code></pre></td></tr></table></figure>

<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><a href="https://blog.csdn.net/fdqw_sph/article/details/54233971">c++中的string常用函数用法总结_c++string函数-CSDN博客</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(num,c)</span> <span class="hljs-comment">//生成一个字符串，包含num个c字符</span></span><br><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(str,\stridx,\strlen)</span> <span class="hljs-comment">//将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</span></span><br></code></pre></td></tr></table></figure>

<h3 id="插入-删除字符-串"><a href="#插入-删除字符-串" class="headerlink" title="插入&#x2F;删除字符 (串)"></a>插入&#x2F;删除字符 (串)</h3><p><code>insert (index, count, ch)</code> 和 <code>insert (index, str)</code> 是比较常见的插入函数。它们分别表示在 <code>index</code> 处连续插入 <code>count</code> 次字符串 $ch$ 和插入字符串 $str$ 。时间复杂度 $O(|s|-index+count)$ 。</p>
<p><code>erase(index, count)</code> 函数将字符串 <code>index</code> 位置开始 (含) 的 <code>count</code> 个字符删除（若不传参给 <code>count</code> 则表示删去 <code>index</code> 位置及以后的所有字符）。</p>
<h2 id="字符串整数互换"><a href="#字符串整数互换" class="headerlink" title="字符串整数互换"></a>字符串整数互换</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> num;<br>num = std::<span class="hljs-built_in">stoi</span>(str)   <span class="hljs-comment">// string -&gt; int</span><br>num = std::<span class="hljs-built_in">stoll</span>(str)   <span class="hljs-comment">// string -&gt; long long</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;456&quot;</span>;<br><span class="hljs-type">int</span> num = std::<span class="hljs-built_in">atoi</span>(str);   <span class="hljs-comment">// char -&gt; int</span><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> num = <span class="hljs-number">123</span>;<br>std::string str = <span class="hljs-built_in">to_string</span>(num); <span class="hljs-comment">// int -&gt; string</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++板子</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>算法</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>python代码</title>
    <url>/2024/12/20/python%E7%AC%94%E8%AE%B0/%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>python代码</p>
<span id="more"></span>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> decimal<br><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal, getcontext<br>getcontext().prec = <span class="hljs-number">100</span> <br>pi=Decimal(<span class="hljs-string">&quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;</span>)<br>a=b=mi=<span class="hljs-number">1000000000000000000</span><br>n=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>());<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    l=<span class="hljs-built_in">input</span>().split()<br>    P,A=Decimal(l[<span class="hljs-number">0</span>]),Decimal(l[<span class="hljs-number">1</span>])<br>    t=<span class="hljs-built_in">abs</span>(P/A-pi)<br>    <span class="hljs-keyword">if</span>(t&lt;mi <span class="hljs-keyword">or</span> (t==mi <span class="hljs-keyword">and</span> P&lt;a)):<br>        mi=t; a=P; b=A;<br><span class="hljs-built_in">print</span>(a,b)<br></code></pre></td></tr></table></figure>

<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> decimal<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal, getcontext<br>getcontext().prec = <span class="hljs-number">25</span><br>pi=Decimal(<span class="hljs-string">&quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;</span>)<br>a=b=mi=<span class="hljs-number">1000000000000000000</span><br><span class="hljs-built_in">input</span> = sys.stdin.read<br>date=<span class="hljs-built_in">input</span>().split()<br>n=<span class="hljs-built_in">int</span>(date[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    P=Decimal(date[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>])<br>    A=Decimal(date[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>])<br>    t=<span class="hljs-built_in">abs</span>(P/A-pi)<br>    <span class="hljs-keyword">if</span>(t&lt;mi <span class="hljs-keyword">or</span> (t==mi <span class="hljs-keyword">and</span> P&lt;a)):<br>        mi=t; a=P; b=A;<br><span class="hljs-built_in">print</span>(a,b)<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2024/11/25/c++%E6%9D%BF%E5%AD%90/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>数据结构</p>
<span id="more"></span>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>查询 $str(|str|&#x3D;m)$ 在 $s(|s|&#x3D;n)$ 中所有出现的位置的起始下标。</p>
<p>$find()$ 的时间复杂度为 $O(n*m)$;</p>
<p>$kmp$ 的时间复杂度为 $O(n+m)$;</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(<span class="hljs-type">char</span> *s,<span class="hljs-type">char</span> *str)</span></span>&#123;<br>    s--,str--;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(str + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ne[len<span class="hljs-number">+10</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; str[i]; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; str[i] != str[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (str[i] == str[j + <span class="hljs-number">1</span>]) j++;<br>        ne[i] = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; s[i]; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != str[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (s[i] == str[j + <span class="hljs-number">1</span>]) j++;<br>        <span class="hljs-keyword">if</span> (j == len) &#123;<br>            cout &lt;&lt; i - len &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;      <span class="hljs-comment">//return;</span><br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kmp</span><span class="hljs-params">(string s, string str)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), m = str.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> ne[m + <span class="hljs-number">10</span>];<br>    ne[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">-1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; str[j + <span class="hljs-number">1</span>] != str[i]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (str[j + <span class="hljs-number">1</span>] == str[i]) j++;<br>        ne[i] = j;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">-1</span> &amp;&amp; s[i] != str[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (s[i] == str[j + <span class="hljs-number">1</span>]) j++;<br>        <span class="hljs-keyword">if</span> (j == m - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; i - j &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            j = ne[j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p><img src="/../images/trie1.png" alt="trie1"></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="普通并查集"><a href="#普通并查集" class="headerlink" title="普通并查集"></a>普通并查集</h3><h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>时间复杂度 $O\left(m \log _{1+\frac{m}{n}} n\right)$（ $m$ 为操作数 ），近似 $O(1)$ 。<a href="https://www.luogu.com/article/x3u368oh">时间复杂度-势能分析浅谈 </a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span>&#123;<br>	vector&lt;<span class="hljs-type">int</span>&gt; p;<br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">p</span>(n)&#123;<br>		<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(x!=p[x]) <span class="hljs-keyword">return</span> p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>		<span class="hljs-keyword">return</span> p[x];<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>		p[<span class="hljs-built_in">find</span>(x)]=<span class="hljs-built_in">find</span>(y);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="启发式合并-路径压缩"><a href="#启发式合并-路径压缩" class="headerlink" title="启发式合并+路径压缩"></a>启发式合并+路径压缩</h4><p>时间复杂度 $O(m\alpha (n))$ ，$\alpha (n)$ 近似看成常数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span>&#123;<br>	vector&lt;<span class="hljs-type">int</span>&gt; p,size;<br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n):<span class="hljs-built_in">p</span>(n),<span class="hljs-built_in">size</span>(n,<span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(x!=p[x]) <span class="hljs-keyword">return</span> p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>		<span class="hljs-keyword">return</span> p[x];<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>		x=<span class="hljs-built_in">find</span>(x),y=<span class="hljs-built_in">find</span>(y);<br>		<span class="hljs-keyword">if</span>(x==y) <span class="hljs-keyword">return</span> ;<br>		<span class="hljs-keyword">if</span>(size[x]&gt;size[y]) <span class="hljs-built_in">swap</span>(x,y);<br>		p[x]=y,size[y]+=size[x];<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>

<h3 id="扩展域并查集"><a href="#扩展域并查集" class="headerlink" title="扩展域并查集"></a>扩展域并查集</h3><p><a href="https://www.luogu.com.cn/problem/P2024">食物链 - 洛谷 </a></p>
<p>对于 $i∈[1,n]$ ，我们用 $i+n$ 表示 $i$ 的天敌，用 $i+2n$ 表示它的食物，合并的时候按照关系合并同类型的动物就可以了。</p>
<p>比如：对于动物 $x$ 和它的天敌 $y$ ，我们可以 ：</p>
<p>$merge(x+n,y),merge(x+2∗n,y+n),merge(x,y+2∗n)$</p>
<p>表示合并 $x$ 的天敌和 $y$ ，合并 $x$ 的食物和 $y$ 的天敌，合并 $x$ 和 $y$ 的食物。</p>
<p>对于同类动物 $x$ 和 $y$ ，我们可以：</p>
<p>$merge(x,y),merge(x+n,y+n),merge(x+2∗n,y+2∗n)$</p>
<p>这样对某个元素 $x$ ，如果有 $same(x,x+n)&#x3D;&#x3D;true||same(x,x+2∗n)&#x3D;&#x3D;true$ 那么一定有命题是错误的。</p>
<h3 id="加权并查集"><a href="#加权并查集" class="headerlink" title="加权并查集"></a>加权并查集</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DSU</span>&#123;<br>	<span class="hljs-type">int</span> m;<br>	vector&lt;<span class="hljs-type">int</span>&gt; p,v;<br>	<span class="hljs-comment">//n：大小，m：最大坐标+1（种类数）</span><br>	<span class="hljs-comment">//v[i]：i据父节点距离，使用时需先same或find，将i的祖宗节点变为父节点，这时v[i]代表其坐标。</span><br>	<span class="hljs-built_in">DSU</span>(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m):<span class="hljs-built_in">m</span>(m),<span class="hljs-built_in">p</span>(n),<span class="hljs-built_in">v</span>(n,<span class="hljs-number">0</span>)&#123;<br>		<span class="hljs-built_in">iota</span>(p.<span class="hljs-built_in">begin</span>(),p.<span class="hljs-built_in">end</span>(),<span class="hljs-number">0</span>);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(x!=p[x])&#123;<br>			<span class="hljs-type">int</span> px=p[x];<br>			p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>			v[x]=(v[x]+v[px])%m;<br>		&#125;<br>		<span class="hljs-keyword">return</span> p[x];<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> dis)</span></span>&#123;<br>		<span class="hljs-type">int</span> fx=<span class="hljs-built_in">find</span>(x),fy=<span class="hljs-built_in">find</span>(y);<br>		<span class="hljs-keyword">if</span>(fx!=fy)&#123;<br>			v[fx]=(dis+v[y]-v[x]+m)%m;<br>			p[fx]=fy;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x)==<span class="hljs-built_in">find</span>(y);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>		<span class="hljs-built_in">find</span>(x);<br>		<span class="hljs-keyword">return</span> v[x];<br>	&#125;<br>	<br>	<span class="hljs-comment">//获取x，y的距离</span><br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fc</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>		<span class="hljs-keyword">return</span> (<span class="hljs-built_in">fc</span>(x)-<span class="hljs-built_in">fc</span>(y)+m)%m;<br>	&#125;<br>&#125;<span class="hljs-built_in">dsu</span>(N,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p><span style='color:red;background:背景颜色;font-size:文字大小;font-family:宋体;'>开long long</span></p>
<p><strong>区间修改 + 单点查询</strong> 用差分可以改为 <strong>单点修改 + 区间查询</strong></p>
<p>用差分时注意数组越界问题</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>线段树可以在 $O(logN)$ 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等</p>
<h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a>区间和</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> l,r,sum,lz;<br>&#125;tree[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	tree[u].sum=tree[u&lt;&lt;<span class="hljs-number">1</span>].sum+tree[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node&amp; f,node&amp; ls,node&amp; rs)</span></span>&#123;<br>	ls.sum+=(ls.r-ls.l<span class="hljs-number">+1</span>)*f.lz;<br>	rs.sum+=(rs.r-rs.l<span class="hljs-number">+1</span>)*f.lz;<br>	ls.lz+=f.lz; rs.lz+=f.lz; f.lz=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	<span class="hljs-built_in">pushdown</span>(tree[u],tree[u&lt;&lt;<span class="hljs-number">1</span>],tree[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	tree[u]=node&#123;l,r,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>	<span class="hljs-keyword">if</span>(l==r)&#123;<br>		tree[u].sum=a[l];<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>	<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,r);<br>	<span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r)&#123;<br>		tree[u].lz+=k;<br>		tree[u].sum+=(tree[u].r-tree[u].l<span class="hljs-number">+1</span>)*k;<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<span class="hljs-built_in">pushdown</span>(u);<br>	<span class="hljs-type">int</span> mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br>	<span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>	<span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r) <span class="hljs-keyword">return</span> tree[u].sum;<br>	<span class="hljs-built_in">pushdown</span>(u);<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l&lt;=mid) ans+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>	<span class="hljs-keyword">if</span>(r&gt;mid) ans+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="加法乘法混合"><a href="#加法乘法混合" class="headerlink" title="加法乘法混合"></a>加法乘法混合</h3><p>转化成先乘再加</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">200010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>	<span class="hljs-type">int</span> l,r,sum,add,mul;<br>&#125;tree[N&lt;&lt;<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n,mod,q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	tree[u].sum=tree[u&lt;&lt;<span class="hljs-number">1</span>].sum+tree[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>].sum;<br>	tree[u].sum%=mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(node&amp; f,node&amp; ls,node&amp; rs)</span></span>&#123;<br>	ls.sum=(ls.sum*f.mul+(ls.r-ls.l<span class="hljs-number">+1</span>)*f.add)%mod;<br>	rs.sum=(rs.sum*f.mul+(rs.r-rs.l<span class="hljs-number">+1</span>)*f.add)%mod;<br>	ls.mul=(ls.mul*f.mul)%mod;<br>	rs.mul=(rs.mul*f.mul)%mod;<br>	ls.add=(ls.add*f.mul+f.add)%mod;<br>	rs.add=(rs.add*f.mul+f.add)%mod;<br>	f.add=<span class="hljs-number">0</span>;<br>	f.mul=<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>	<span class="hljs-built_in">pushdown</span>(tree[u],tree[u&lt;&lt;<span class="hljs-number">1</span>],tree[u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	tree[u]=node&#123;l,r,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>	<span class="hljs-keyword">if</span>(l==r)&#123;<br>		tree[u].sum=a[l];<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<span class="hljs-type">int</span> mid=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,mid);<br>	<span class="hljs-built_in">build</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,mid<span class="hljs-number">+1</span>,r);<br>	<span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r)&#123;<br>		tree[u].add+=k;<br>		tree[u].add%=mod;<br>		tree[u].sum+=(tree[u].r-tree[u].l<span class="hljs-number">+1</span>)*k;<br>		tree[u].sum%=mod;<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<span class="hljs-built_in">pushdown</span>(u);<br>	<span class="hljs-type">int</span> mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br>	<span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">add</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>	<span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r)&#123;<br>		tree[u].mul*=k;<br>		tree[u].add*=k;<br>		tree[u].sum*=k;<br>		tree[u].mul%=mod;<br>		tree[u].add%=mod;<br>		tree[u].sum%=mod;<br>		<span class="hljs-keyword">return</span> ;<br>	&#125;<br>	<span class="hljs-built_in">pushdown</span>(u);<br>	<span class="hljs-type">int</span> mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l&lt;=mid) <span class="hljs-built_in">mul</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r,k);<br>	<span class="hljs-keyword">if</span>(r&gt;mid) <span class="hljs-built_in">mul</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r,k);<br>	<span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>	<span class="hljs-keyword">if</span>(l&lt;=tree[u].l&amp;&amp;tree[u].r&lt;=r) <span class="hljs-keyword">return</span> tree[u].sum;<br>	<span class="hljs-built_in">pushdown</span>(u);<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,mid=(tree[u].l+tree[u].r)&gt;&gt;<span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span>(l&lt;=mid) ans+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>,l,r);<br>	<span class="hljs-keyword">if</span>(r&gt;mid) ans+=<span class="hljs-built_in">query</span>(u&lt;&lt;<span class="hljs-number">1</span>|<span class="hljs-number">1</span>,l,r);<br>	<span class="hljs-keyword">return</span> ans%mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cin&gt;&gt;n&gt;&gt;q&gt;&gt;mod;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>	<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,n);<br>	<span class="hljs-keyword">while</span>(q--)&#123;<br>		<span class="hljs-comment">//for(int i=1;i&lt;=10;i++) cout&lt;&lt;tree[i].l&lt;&lt;&quot; &quot;&lt;&lt;tree[i].r&lt;&lt;&quot; &quot;&lt;&lt;tree[i].sum&lt;&lt;&quot;\n&quot;;</span><br>		<span class="hljs-type">int</span> op,x,y,k;<br>		cin&gt;&gt;op;<br>		<span class="hljs-keyword">if</span>(op==<span class="hljs-number">1</span>)&#123;<br>			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;<br>			<span class="hljs-built_in">mul</span>(<span class="hljs-number">1</span>,x,y,k);<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op==<span class="hljs-number">2</span>)&#123;<br>			cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;<br>			<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,x,y,k);<br>		&#125;<br>		<span class="hljs-keyword">else</span>&#123;<br>			cin&gt;&gt;x&gt;&gt;y;<br>			cout&lt;&lt;<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>,x,y)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>		&#125;<br>		<span class="hljs-comment">//cout&lt;&lt;&quot;\n&quot;;</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">越界  <span class="hljs-built_in">n</span>+<span class="hljs-number">10</span><br>区间修改，查询操作前先 pushdown<br>修改之后 pushup<br>pushdown函数记得把父节点的懒标记清空<br></code></pre></td></tr></table></figure>

<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p><img src="/../images/002.png" alt="002"></p>
<p>树状数组思想<br>树状数组的本质思想是使用树结构维护”前缀和”，从而把时间复杂度降为 $O(logn)$ 。</p>
<p>对于一个序列，对其建立如下树形结构：</p>
<ol>
<li><p>每个结点 $t[x]$ 保存以 $x$ 为根的子树中叶结点值的和</p>
</li>
<li><p>每个结点覆盖的长度为 $lowbit(x)$</p>
</li>
<li><p>$t[x]$ 结点的父结点为 $t[x + lowbit(x)]$</p>
</li>
<li><p>树的深度为 $log_2n+1$</p>
</li>
</ol>
<p>修改：将 $u$ 的所有祖宗节点加 $x$ 。</p>
<p>查询：$[l,r]$ 的区间和是 $ask(r) - ask(l-1)$ 。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>下标不能从 $0$ 开始。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tree</span> &#123;<br>	<span class="hljs-type">int</span> n;<br>	vector&lt;<span class="hljs-type">int</span>&gt; t;<br><br>	<span class="hljs-built_in">tree</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">n</span>(n), <span class="hljs-built_in">t</span>(n + <span class="hljs-number">10</span>) &#123;&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> x &amp; (-x);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i &lt;= n; i = i + <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>			t[i] += k;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>		<span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = x; i; i = i - <span class="hljs-built_in">lowbit</span>(i)) &#123;<br>			ans += t[i];<br>		&#125;<br>		<span class="hljs-keyword">return</span> ans;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">ask</span>(r) - <span class="hljs-built_in">ask</span>(l - <span class="hljs-number">1</span>);<br>	&#125;<br>&#125;;<br><br><span class="hljs-function">tree <span class="hljs-title">tr</span><span class="hljs-params">(n)</span></span>;<br></code></pre></td></tr></table></figure>

<h3 id="1-单点修改-区间查询"><a href="#1-单点修改-区间查询" class="headerlink" title="1. 单点修改 + 区间查询"></a>1. 单点修改 + 区间查询</h3><p>前缀和</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> t[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-keyword">return</span> x&amp;(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i&lt;=n;i=i+<span class="hljs-built_in">lowbit</span>(i))&#123;<br>		t[i]+=k;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>	<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;i;i=i-<span class="hljs-built_in">lowbit</span>(i))&#123;<br>		ans+=t[i];<br>	&#125;<br>	<span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-comment">// x位置加k</span><br><span class="hljs-built_in">add</span>(x,k);<br><br>cout&lt;&lt;(<span class="hljs-built_in">ask</span>(r)-<span class="hljs-built_in">ask</span>(l<span class="hljs-number">-1</span>))&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="2-区间修改-单点查询"><a href="#2-区间修改-单点查询" class="headerlink" title="2. 区间修改 + 单点查询"></a>2. 区间修改 + 单点查询</h3><p>差分</p>
<p>树状数组函数和上者一样，不同的是使用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 区间[x,y]加 k</span><br><span class="hljs-built_in">add</span>(x,k);<br><span class="hljs-built_in">add</span>(y<span class="hljs-number">+1</span>,-k);<br><br><span class="hljs-comment">// 询问a[x]</span><br>cout&lt;&lt;<span class="hljs-built_in">ask</span>(x)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="3-区间修改-区间查询"><a href="#3-区间修改-区间查询" class="headerlink" title="3. 区间修改 + 区间查询"></a>3. 区间修改 + 区间查询</h3><p>这是最常用的部分，也是用线段树写着最麻烦的部分——但是现在我们有了树状数组!<br>怎么求呢? 我们基于问题2的”差分”思路，考虑一下如何在问题2构建的树状数组中求前缀和:<br>位置 $p$ 的前缀和 $&#x3D;$<br>$$<br>\sum_{i&#x3D;1}^p a[i]&#x3D;\sum_{i&#x3D;1}^p \sum_{j&#x3D;1}^i d[j]<br>$$</p>
<p>在等式最右侧的式子 $\sum_{i&#x3D;1}^p \sum_{j&#x3D;1}^i d[j]$ 中， $d[1]$ 被用了 $p$ 次， $d[2]$ 被用了 $p-1$ 次…..那么我们可以写出:<br>位置p的前缀和 $&#x3D;$<br>$$<br>\sum_{i&#x3D;1}^p \sum_{j&#x3D;1}^i d[j]&#x3D;\sum_{i&#x3D;1}^p d[i] *(p-i+1)&#x3D;(p+1) * \sum_{i&#x3D;1}^p d[i]-\sum_{i&#x3D;1}^p d[i] * i<br>$$</p>
<p>那么我们可以维护两个数组的前缀和:</p>
<p>一个数组是 $\operatorname{sum} 1[i]&#x3D;d[i]$ ，</p>
<p>另一个数组是 $\operatorname{sum} 2[i]&#x3D;d[i] * i$ 。<br><strong>查询</strong><br>位置p的前缀和即： $(p+1) * sum1$ 数组中 $p$ 的前缀和 - sum2数组中 $p$ 的前缀和。</p>
<p>区间 $[l, r]$ 的和即：位置 $r$ 的前缀和 $-$ 位置 $l$ 的前缀和。<br><strong>修改</strong></p>
<p>对于 $sum1$ 数组的修改同问题 2 中对 d 数组的修改。</p>
<p>对于 $sum2$ 数组的修改也类似，我们给 $sum2[l]$ 加上 $l * x$ ，给 $sum2[r+1]$ 减去 $(r+1) * x$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>

<h3 id="4-二维树状数组"><a href="#4-二维树状数组" class="headerlink" title="4. 二维树状数组"></a>4. 二维树状数组</h3><h2 id="st表"><a href="#st表" class="headerlink" title="st表"></a>st表</h2><p>ST表（Sparse Table，稀疏表）是一种简单的数据结构，主要用来解决RMQ（Range Maximum&#x2F;Minimum Query，区间最大&#x2F;最小值查询）问题。它主要应用倍增的思想，可以实现 $O(nlogn)$ 预处理、$O(1)$ 查询。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1e6</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">22</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) f[i][<span class="hljs-number">0</span>] = a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span>; ++i)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j + (<span class="hljs-number">1</span> &lt;&lt; i) - <span class="hljs-number">1</span> &lt;= n; ++j)<br>        f[j][i] = <span class="hljs-built_in">max</span>(f[j][i - <span class="hljs-number">1</span>], f[j + (<span class="hljs-number">1</span> &lt;&lt; (i - <span class="hljs-number">1</span>))][i - <span class="hljs-number">1</span>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>    cin&gt;&gt;l&gt;&gt;r;<br>    <span class="hljs-type">int</span> s = __lg(r - l + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">max</span>(f[l][s], f[r - (<span class="hljs-number">1</span> &lt;&lt; s) + <span class="hljs-number">1</span>][s]));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>$log2()$ 函数手写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i)<br>    Log2[i] = Log2[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;	<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>python语法</title>
    <url>/2024/12/20/python%E7%AC%94%E8%AE%B0/%E9%98%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>python语法</p>
<span id="more"></span>

<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="1-导入头文件"><a href="#1-导入头文件" class="headerlink" title="1. 导入头文件"></a>1. 导入头文件</h3><p>在Python中，我们使用<code>import</code>语句来导入头文件。有多种导入方式，常见的有以下两种形式：</p>
<ul>
<li><code>import 模块名</code>: 导入整个模块，并使用模块名作为前缀访问其中的函数和变量。</li>
<li><code>from 模块名 import 备用名</code>: 导入模块中的指定函数、变量或类，可以直接使用备用名访问而不需要前缀。</li>
</ul>
<p>下面是一个简单的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-built_in">print</span>(math.pi)	<span class="hljs-comment"># 输出3.141592653589793</span><br><br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt   // 可以将math.sqrt的math去掉<br><span class="hljs-built_in">print</span>(sqrt(<span class="hljs-number">16</span>))  <br></code></pre></td></tr></table></figure>

<h3 id="2-重命名导入的模块或变量"><a href="#2-重命名导入的模块或变量" class="headerlink" title="2. 重命名导入的模块或变量"></a>2. 重命名导入的模块或变量</h3><p>在导入头文件时，我们可以使用<code>as</code>关键字来重命名导入的模块或变量。这样可以方便我们调用，避免名字冲突等问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math <span class="hljs-keyword">as</span> m<br><span class="hljs-built_in">print</span>(m.sqrt(<span class="hljs-number">25</span>))<br><br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> pi <span class="hljs-keyword">as</span> p<br><span class="hljs-built_in">print</span>(p)<br></code></pre></td></tr></table></figure>

<h3 id="3-导入整个模块的所有内容"><a href="#3-导入整个模块的所有内容" class="headerlink" title="3. 导入整个模块的所有内容"></a>3. 导入整个模块的所有内容</h3><p>有时候，我们希望一次性导入整个模块的所有函数和变量，而不需要使用模块名前缀。可以使用<code>from 模块名 import *</code>的方式来实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> *<br><span class="hljs-built_in">print</span>(sqrt(<span class="hljs-number">9</span>))<br><span class="hljs-built_in">print</span>(pi)<br></code></pre></td></tr></table></figure>

<h2 id="常用函数-数据类型"><a href="#常用函数-数据类型" class="headerlink" title="常用函数&#x2F;数据类型"></a>常用函数&#x2F;数据类型</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><a href="https://blog.csdn.net/wuShiJingZuo/article/details/135620145">Python中常用的函数：map()详解_python map-CSDN博客</a></p>
<h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p><a href="https://blog.csdn.net/Broken_x/article/details/139371467">深入理解Python中的元组 ——Tuple（）_元组(tuple)-CSDN博客</a></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>input().split()返回的是列表</p>
<p><a href="https://blog.csdn.net/m0_70885101/article/details/126022872">Python 列表list详解（超详细）_python list-CSDN博客</a></p>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>python常用库</title>
    <url>/2024/12/20/python%E7%AC%94%E8%AE%B0/%E5%B8%B8%E7%94%A8%E5%BA%93/</url>
    <content><![CDATA[<p>python常用库</p>
<span id="more"></span>

<h2 id="decimal"><a href="#decimal" class="headerlink" title="decimal"></a>decimal</h2><p><a href="https://blog.csdn.net/qq_39147299/article/details/124200896">【python】Decimal的使用</a></p>
<p>用于浮点数和较大的数据进行运算。</p>
<h3 id="1-精度"><a href="#1-精度" class="headerlink" title="1.精度"></a>1.精度</h3><p>decimal的精度默认是28位，可以自定义，通过getcontext获取线程上下文，然后修改prec属性即可</p>
<p>prec代表有效数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal, getcontext<br><br><span class="hljs-built_in">print</span>(getcontext().prec)  <span class="hljs-comment"># 计算精度，默认是28  </span><br>getcontext().prec = <span class="hljs-number">100</span>  <span class="hljs-comment"># 可修改</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># from decimal import Decimal,Context,setcontext</span><br><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> *<br>setcontext(Context(prec=<span class="hljs-number">10000000</span>,Emax=<span class="hljs-number">3000000</span>,Emin=<span class="hljs-number">0</span>))   <span class="hljs-comment">#有效数字，最大指数，最小指数</span><br></code></pre></td></tr></table></figure>

<h3 id="2-Decimal"><a href="#2-Decimal" class="headerlink" title="2.Decimal"></a>2.Decimal</h3><p>通过实例化Decimal对象时传入value参数把其他的数据类型转换成Decimal类型。注意，尽量传入整数和字符串，如果传入float会导致结果不准确（float本身就存在精度问题）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = Decimal(<span class="hljs-string">&quot;5632569878.6514126&quot;</span>)  <span class="hljs-comment"># 字符串</span><br>c = Decimal(<span class="hljs-number">63</span>)  <span class="hljs-comment"># 整数</span><br>d = Decimal.from_float(<span class="hljs-number">6.325</span>)  <span class="hljs-comment"># Decimal(6.32500000000000017763568394002504646778106689453125), 不准确</span><br></code></pre></td></tr></table></figure>

<p>Decimal类型也可以像python基本数据类型那样进行加减乘除等运算，运算完后还是Decimal类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">a = Decimal(<span class="hljs-string">&quot;8.651&quot;</span>)  <span class="hljs-comment"># Decimal(8.651)</span><br>b = Decimal(<span class="hljs-string">&quot;7&quot;</span>)  <span class="hljs-comment"># Decimal(7)</span><br><br><span class="hljs-built_in">print</span>(a // b)  <span class="hljs-comment"># Decimal(1)</span><br><span class="hljs-built_in">print</span>(a ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># Decimal(74.839801)</span><br></code></pre></td></tr></table></figure>

<h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p><code>sys.stdin.read()</code> 的使用是用来从标准输入（stdin）读取所有的数据，直到输入结束（EOF，即文件结束符）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">input</span> = sys.stdin.read<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果是n，m，则date[i*2+0]，date[i*2+1]</span><br>n=<span class="hljs-built_in">int</span>(date[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    a=<span class="hljs-built_in">int</span>(date[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>])<br>    b=<span class="hljs-built_in">int</span>(date[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure>

<h2 id="heapq"><a href="#heapq" class="headerlink" title="heapq"></a>heapq</h2><p><a href="https://blog.csdn.net/chandelierds/article/details/91357784">Python中heapq模块浅析_heapq.heappush-CSDN博客</a></p>
<h2 id="bisect（二分）"><a href="#bisect（二分）" class="headerlink" title="bisect（二分）"></a>bisect（二分）</h2><p><a href="https://www.cnblogs.com/hider/p/14711550.html">https://www.cnblogs.com/hider/p/14711550.html</a></p>
]]></content>
      <categories>
        <category>python笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何</title>
    <url>/2024/11/25/c++%E6%9D%BF%E5%AD%90/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/oneway10101/p/17642080.html#%E6%B1%82%E5%A4%9A%E8%BE%B9%E5%BD%A2%E9%9D%A2%E7%A7%AFpolygon_area">计算几何基本模板（二维）</a></p>
<span id="more"></span>

<p><strong>直线方向向量</strong></p>
<p>对 $Ax+By+C&#x3D;0$ , 法向量 $(A, B)$ , 方向向量 $(-B, A)$ 。</p>
<p>设一般方程: $A x+B y+C&#x3D;0$<br>写成斜截式： $y&#x3D;-\frac{A}{B} x-\frac{C}{B}$<br>那么它的斜率 $k&#x3D;-\frac{A}{B}$<br>过原点做一条平行线 $y&#x3D;-\frac{A}{B} x$<br>取 $x&#x3D;B$ ，得到 $y&#x3D;-A$.那么得到一个方向向量即 $\alpha&#x3D;(B,-A)$ 。</p>
<p><strong>两直线交点</strong></p>
<p>直线 $l_1$ 的一般式为：$$ A_1x + B_1y + C_1 &#x3D; 0 $$<br>直线 $l_2$ 的一般式为：$$ A_2x + B_2y + C_2 &#x3D; 0 $$</p>
<p>两条直线 $l_1$ 和 $l_2$ 的交点是：<br>$$<br>\left( \frac{B_1C_2 - B_2C_1}{A_1B_2 - A_2B_1}, \frac{A_1C_2 - A_2C_1}{A_2B_1 - A_1B_2} \right)<br>$$</p>
<p>注意：如果 $A_2B_1 - A_1B_2 &#x3D; 0$，则方程组无解（平行且不重合）或有无穷多解（重合）。</p>
<p><strong>直线一般式</strong></p>
<p>$fs(x)$ 防止输出 $-0.00$ 。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> fs(x) (abs(x) &lt; eps) ? 0 : (x)</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> x, y;<br><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> node&amp; b)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x == b.x &amp;&amp; y == b.y;<br>	&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>	<span class="hljs-type">double</span> x, y;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b, c;<br><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Line&amp; l)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> a == l.a ? (b == l.b ? c &lt; l.c : b &lt; l.b) : (a &lt; l.a);<br>	&#125;<br><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Line&amp; l)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> a == l.a &amp;&amp; b == l.b &amp;&amp; c == l.c;<br>	&#125;<br><br>	<span class="hljs-comment">// 直线是否过点A</span><br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">through</span><span class="hljs-params">(node A)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> a * A.x + b * A.y + c == <span class="hljs-number">0</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// l1,l2是否相交</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">intersect</span><span class="hljs-params">(Line l1, Line l2)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> !(l<span class="hljs-number">1.</span>a * l<span class="hljs-number">2.</span>b == l<span class="hljs-number">1.</span>b * l<span class="hljs-number">2.</span>a);<br>&#125;<br><br><span class="hljs-comment">// l1,l2交点</span><br><span class="hljs-function">Point <span class="hljs-title">intersection</span><span class="hljs-params">(Line l1, Line l2)</span> </span>&#123;<br>	<span class="hljs-type">double</span> A1 = l<span class="hljs-number">1.</span>a, B1 = l<span class="hljs-number">1.</span>b, C1 = l<span class="hljs-number">1.</span>c, A2 = l<span class="hljs-number">2.</span>a, B2 = l<span class="hljs-number">2.</span>b, C2 = l<span class="hljs-number">2.</span>c;<br>	<span class="hljs-keyword">return</span> &#123; (B1 * C2 - B2 * C1) / (A1 * B2 - A2 * B1),(A1 * C2 - A2 * C1) / (A2 * B1 - A1 * B2) &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a, <span class="hljs-type">long</span> <span class="hljs-type">long</span> b)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (!b) <span class="hljs-keyword">return</span> a;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// x1,x2不能相等</span><br><span class="hljs-function">Line <span class="hljs-title">make_line</span><span class="hljs-params">(node x1, node x2)</span> </span>&#123;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> a = x<span class="hljs-number">1.</span>y - x<span class="hljs-number">2.</span>y;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> b = x<span class="hljs-number">2.</span>x - x<span class="hljs-number">1.</span>x;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> c = x<span class="hljs-number">1.</span>x * x<span class="hljs-number">2.</span>y - x<span class="hljs-number">1.</span>y * x<span class="hljs-number">2.</span>x;<br>	<span class="hljs-type">long</span> <span class="hljs-type">long</span> g = <span class="hljs-built_in">gcd</span>(a, <span class="hljs-built_in">gcd</span>(b, c));<br>	a /= g, b /= g, c /= g;<br>	<span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) &#123;<br>		a = -a, b = -b, c = -c;<br>	&#125;<br>	<span class="hljs-keyword">return</span> Line&#123; a,b,c &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>凸包</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> Pi = <span class="hljs-number">3.141592653589793</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>	<span class="hljs-type">double</span> x, y;<br><br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; b)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x != b.x ? x &lt; b.x : y &lt; b.y;<br>	&#125;<br><br>	Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point&amp; b)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> &#123; x + b.x,y + b.y &#125;;<br>	&#125;<br><br>    <span class="hljs-comment">// 向量</span><br>	Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point&amp; b)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> &#123; x - b.x,y - b.y &#125;;<br>	&#125;<br><br>    <span class="hljs-comment">// 点积</span><br>	<span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Point&amp; b)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x * b.x + y * b.y;<br>	&#125;<br><br>    <span class="hljs-comment">// 叉积</span><br>	<span class="hljs-type">double</span> <span class="hljs-keyword">operator</span>^(<span class="hljs-type">const</span> Point&amp; b)<span class="hljs-type">const</span> &#123;<br>		<span class="hljs-keyword">return</span> x * b.y - y * b.x;<br>	&#125;<br><br>    <span class="hljs-comment">// 两点距离</span><br>	<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dis</span><span class="hljs-params">(Point b)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">hypot</span>(x - b.x, y - b.y);<br>	&#125;<br><br>    <span class="hljs-comment">// 绕p逆时针转angle弧度</span><br>	<span class="hljs-function">Point <span class="hljs-title">rotate</span><span class="hljs-params">(Point p, <span class="hljs-type">double</span> angle)</span> </span>&#123;<br>		Point v = (*<span class="hljs-keyword">this</span>) - p;<br>		<span class="hljs-type">double</span> c = <span class="hljs-built_in">cos</span>(angle), s = <span class="hljs-built_in">sin</span>(angle);<br>		<span class="hljs-keyword">return</span> &#123; p.x + v.x * c - v.y * s,p.y + v.y * c + v.x * s &#125;;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_right</span><span class="hljs-params">(Point a, Point b, Point c)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> ((c - a) ^ (b - a)) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(p + <span class="hljs-number">1</span>, p + <span class="hljs-number">1</span> + size);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size; i++) &#123;<br>	<span class="hljs-keyword">while</span> (tt &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">is_right</span>(stk[tt - <span class="hljs-number">1</span>], stk[tt], p[i])) tt--;<br>	stk[++tt] = p[i];<br>&#125;<br><span class="hljs-type">int</span> len = tt;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = size; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>	<span class="hljs-keyword">while</span> (tt &gt;= len + <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">is_right</span>(stk[tt - <span class="hljs-number">1</span>], stk[tt], p[i])) tt--;<br>	stk[++tt] = p[i];<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>c++板子</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>c++</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
</search>
